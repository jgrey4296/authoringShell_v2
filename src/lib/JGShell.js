!function(n,e){"object"==typeof exports&&"object"==typeof module?module.exports=e(require("lodash")):"function"==typeof define&&define.amd?define(["lodash"],e):"object"==typeof exports?exports.JGShell=e(require("lodash")):n.JGShell=e(n._)}("undefined"!=typeof self?self:this,function(__WEBPACK_EXTERNAL_MODULE_lodash__){return function(n){var e={};function t(r){if(e[r])return e[r].exports;var o=e[r]={i:r,l:!1,exports:{}};return n[r].call(o.exports,o,o.exports,t),o.l=!0,o.exports}return t.m=n,t.c=e,t.d=function(n,e,r){t.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:r})},t.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},t.t=function(n,e){if(1&e&&(n=t(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var r=Object.create(null);if(t.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var o in n)t.d(r,o,function(e){return n[e]}.bind(null,o));return r},t.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return t.d(e,"a",e),e},t.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},t.p="",t(t.s="./Shell.js")}({"../libs/rete.js":
/*!***********************!*\
  !*** ../libs/rete.js ***!
  \***********************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\n!function (e, n) {\n  "object" == ( false ? undefined : _typeof(exports)) && "object" == ( false ? undefined : _typeof(module)) ? module.exports = n(__webpack_require__(/*! lodash */ "lodash")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! lodash */ "lodash")], __WEBPACK_AMD_DEFINE_FACTORY__ = (n),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;\n}("undefined" != typeof self ? self : this, function (__WEBPACK_EXTERNAL_MODULE_lodash__) {\n  return function (e) {\n    var n = {};\n\n    function t(o) {\n      if (n[o]) return n[o].exports;\n      var r = n[o] = {\n        i: o,\n        l: !1,\n        exports: {}\n      };\n      return e[o].call(r.exports, r, r.exports, t), r.l = !0, r.exports;\n    }\n\n    return t.m = e, t.c = n, t.d = function (e, n, o) {\n      t.o(e, n) || Object.defineProperty(e, n, {\n        enumerable: !0,\n        get: o\n      });\n    }, t.r = function (e) {\n      "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {\n        value: "Module"\n      }), Object.defineProperty(e, "__esModule", {\n        value: !0\n      });\n    }, t.t = function (e, n) {\n      if (1 & n && (e = t(e)), 8 & n) return e;\n      if (4 & n && "object" == _typeof(e) && e && e.__esModule) return e;\n      var o = Object.create(null);\n      if (t.r(o), Object.defineProperty(o, "default", {\n        enumerable: !0,\n        value: e\n      }), 2 & n && "string" != typeof e) for (var r in e) {\n        t.d(o, r, function (n) {\n          return e[n];\n        }.bind(null, r));\n      }\n      return o;\n    }, t.n = function (e) {\n      var n = e && e.__esModule ? function () {\n        return e.default;\n      } : function () {\n        return e;\n      };\n      return t.d(n, "a", n), n;\n    }, t.o = function (e, n) {\n      return Object.prototype.hasOwnProperty.call(e, n);\n    }, t.p = "", t(t.s = "./ReteClassInterface.js");\n  }({\n    "./ReteActionAssert.js":\n    /*!*****************************!*\\\n      !*** ./ReteActionAssert.js ***!\n      \\*****************************/\n\n    /*! exports provided: default */\n    function ReteActionAssertJs(module, __webpack_exports__, __webpack_require__) {\n      "use strict";\n\n      eval(\'__webpack_require__.r(__webpack_exports__);\\n/* harmony import */ var _ReteDataStructures__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ReteDataStructures */ "./ReteDataStructures.js");\\n/**\\n   Defines the Assert Action\\n   @module ReteActionAssert\\n   @requires ReteArithmeticActions\\n   @requires ReteUtilities\\n   @requires ReteDataStructures\\n   @requires lodash\\n*/\\n\\n/**\\n   @implements {module:ReteActionInterface}\\n   @class AssertAction\\n */\\n\\nvar AssertAction = {\\n  "name": "assert",\\n  propose: null,\\n  perform: null\\n};\\n/* harmony default export */ __webpack_exports__["default"] = (AssertAction);\\n/**\\n   Propose the Assertion, will be bound to an action description @alias{RuleCtors:Action}\\n   @param {module:ReteDataStructures.Token} token The token that is emitted by the network\\n   @param {module:ReteClassInterface.ReteNet} reteNet The top level reteNet\\n   @function\\n */\\n\\nAssertAction.propose = function (token, reteNet) {\\n  //create the data object:\\n  var newWMEData = reteNet.utils.createNewWMEData(this, token);\\n  reteNet.utils.applyArithmetic(this, newWMEData);\\n  reteNet.utils.applyRegex(this, newWMEData); //Expand out to object structure\\n  //ie: {values.a:5, tags.type: rule} -> {values:{a:5},tags:{type:rule}}\\n\\n  var complexFormData = reteNet.utils.objDescToObject(newWMEData); //To be returned to activateActionNode\\n\\n  var proposedAction = new reteNet.ProposedAction(reteNet, "assert", this.name, complexFormData, token, reteNet.currentTime, this.timing, this.priority);\\n  return proposedAction;\\n};\\n/**\\n   Perform the Assertion, after having been scheduled\\n   @param {module:ReteDataStructures.ProposedAction} proposedAction\\n   @param {module:ReteClassInterface.ReteNet} reteNet\\n   @function\\n   @return {Object}\\n */\\n\\n\\nAssertAction.perform = function (proposedAction, reteNet) {\\n  //check the type matches\\n  if (proposedAction.actionType !== \\\'assert\\\') {\\n    throw new Error("Expected Assert");\\n  } //Perform the action:\\n\\n\\n  var newWMEID = reteNet.assertWME(proposedAction.payload, proposedAction.retractTime); //schedule the retraction:\\n\\n  if (proposedAction.timing.unperformOffset > 0) {\\n    //schedule a retract, with no invalidate time (its not being proposed)\\n    //and the perform time being the original actions unperformoffset\\n    reteNet.addToSchedule(new _ReteDataStructures__WEBPACK_IMPORTED_MODULE_0__["ProposedAction"](reteNet, "retract", newWMEID, null, reteNet.currentTime, {\\n      invalidateOffset: null,\\n      performOffset: proposedAction.timing.unperformOffset,\\n      unperformOffset: null\\n    }));\\n  }\\n\\n  return {\\n    "asserted": newWMEID\\n  };\\n};\\n\\n//# sourceURL=webpack://Rete/./ReteActionAssert.js?\');\n    },\n    "./ReteActionRetract.js":\n    /*!******************************!*\\\n      !*** ./ReteActionRetract.js ***!\n      \\******************************/\n\n    /*! exports provided: default */\n    function ReteActionRetractJs(module, __webpack_exports__, __webpack_require__) {\n      "use strict";\n\n      eval(\'__webpack_require__.r(__webpack_exports__);\\n/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash */ "lodash");\\n/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);\\n/* harmony import */ var _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ReteDataStructures */ "./ReteDataStructures.js");\\n/**\\n   Defines the Retract Action\\n   @module ReteActionRetract\\n   @requires ReteArithmeticActions\\n   @requires ReteUtilities\\n   @requires ReteDataStructures\\n   @requires lodash\\n*/\\n\\n\\n/**\\n   @class RetractAction\\n   @implements {ReteActionInterface}\\n */\\n\\nvar RetractAction = {\\n  "name": "retract",\\n  propose: null,\\n  perform: null\\n};\\n/* harmony default export */ __webpack_exports__["default"] = (RetractAction);\\n/**\\n   Propose the Retraction\\n   @function\\n */\\n\\nRetractAction.propose = function (token, reteNet) {\\n  var _this = this;\\n\\n  //get all wmes the token touches:\\n  var wmes = [],\\n      currToken = token,\\n      varRegex = /^\\\\${(\\\\w+)}/;\\n\\n  while (currToken && currToken.wme !== undefined) {\\n    wmes.push(currToken.wme);\\n    currToken = currToken.parentToken;\\n  } //Get the keys of the action that have \\\'wme\\\' in them\\n\\n\\n  var wmeKeys = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.keys(this.values).filter(function (d) {\\n    return /^wme([0-9]*)/.test(d);\\n  }),\\n      //get the ones of those that related to a binding in the token\\n  wmeIdBindings = wmeKeys.map(function (d) {\\n    return _this.values[d];\\n  }).filter(function (d) {\\n    return varRegex.test(d);\\n  }),\\n      //get the value for those bindings\\n  wmeIds = wmeIdBindings.map(function (d) {\\n    var match = varRegex.exec(d);\\n    return token.bindings[match[1]];\\n  }); //console.log("Token bindings :",token.bindings);\\n  //console.log("Retrieved wme ids for retraction:",wmeIds);\\n  // //filter the wmeList by the wmeIDs:\\n  // let toRetract = _.filter(wmes,function(wme){\\n  //     return _.contains(wmeIDs,wme.id);\\n  // });\\n  //Propose the list of all wmes to retract\\n\\n\\n  var proposedAction = new _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["ProposedAction"](reteNet, "retract", this.name, wmeIds, token, reteNet.currentTime, this.timing);\\n  return proposedAction;\\n};\\n/**\\n   Perform the retraction\\n   @function\\n */\\n\\n\\nRetractAction.perform = function (proposedAction, reteNet) {\\n  if (proposedAction.actionType !== \\\'retract\\\') {\\n    throw new Error("Expected retract");\\n  } //console.log("Retracting:",proposedAction.payload);\\n\\n\\n  if (proposedAction.payload instanceof Array) {\\n    var retractedWMEs = proposedAction.payload.map(function (d) {\\n      return reteNet.retractWME(d);\\n    });\\n    return {\\n      "retracted": retractedWMEs\\n    };\\n  }\\n\\n  var retractedWME = reteNet.retractWME(proposedAction.payload);\\n  return {\\n    "retracted": [retractedWME]\\n  }; //do anything with the retracted wme(s)?\\n};\\n\\n//# sourceURL=webpack://Rete/./ReteActionRetract.js?\');\n    },\n    "./ReteAction_addRule.js":\n    /*!*******************************!*\\\n      !*** ./ReteAction_addRule.js ***!\n      \\*******************************/\n\n    /*! exports provided: default */\n    function ReteAction_addRuleJs(module, __webpack_exports__, __webpack_require__) {\n      "use strict";\n\n      eval(\'__webpack_require__.r(__webpack_exports__);\\n/* harmony import */ var _ReteDataStructures__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ReteDataStructures */ "./ReteDataStructures.js");\\n\\nvar AddRule = {\\n  "name": "addRule",\\n  propose: null,\\n  perform: null\\n};\\n/* harmony default export */ __webpack_exports__["default"] = (AddRule); //Token + Action Description -> ProposedAction\\n\\nAddRule.propose = function (token, reteNet) {\\n  //Propose the list of all wmes to retract\\n  //TODO: Check this\\n  var proposedAction = new _ReteDataStructures__WEBPACK_IMPORTED_MODULE_0__["ProposedAction"](reteNet, "NO-OP", this.name, token.wme, token, reteNet.currentTime, this.timing);\\n  return proposedAction;\\n}; //ProposedAction -> Performance\\n\\n\\nAddRule.perform = function (proposedAction, reteNet) {\\n  console.log("No-op");\\n};\\n\\n//# sourceURL=webpack://Rete/./ReteAction_addRule.js?\');\n    },\n    "./ReteAction_removeRule.js":\n    /*!**********************************!*\\\n      !*** ./ReteAction_removeRule.js ***!\n      \\**********************************/\n\n    /*! exports provided: default */\n    function ReteAction_removeRuleJs(module, __webpack_exports__, __webpack_require__) {\n      "use strict";\n\n      eval(\'__webpack_require__.r(__webpack_exports__);\\n/* harmony import */ var _ReteDataStructures__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ReteDataStructures */ "./ReteDataStructures.js");\\n\\nvar RemoveRule = {\\n  "name": "removeRule",\\n  propose: null,\\n  perform: null\\n};\\n/* harmony default export */ __webpack_exports__["default"] = (RemoveRule); //Token + Action Description -> ProposedAction\\n\\nRemoveRule.propose = function (token, reteNet) {\\n  //Propose the list of all wmes to retract\\n  var proposedAction = new _ReteDataStructures__WEBPACK_IMPORTED_MODULE_0__["ProposedAction"](reteNet, "NO-OP", this.name, token.wme, token, reteNet.currentTime, this.timing);\\n  return proposedAction;\\n}; //ProposedAction -> performance\\n\\n\\nRemoveRule.perform = function (proposedAction, reteNet) {\\n  console.log("No-op");\\n};\\n\\n//# sourceURL=webpack://Rete/./ReteAction_removeRule.js?\');\n    },\n    "./ReteActions.js":\n    /*!************************!*\\\n      !*** ./ReteActions.js ***!\n      \\************************/\n\n    /*! exports provided: default */\n    function ReteActionsJs(module, __webpack_exports__, __webpack_require__) {\n      "use strict";\n\n      eval(\'__webpack_require__.r(__webpack_exports__);\\n/* harmony import */ var _ReteActionAssert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ReteActionAssert */ "./ReteActionAssert.js");\\n/* harmony import */ var _ReteActionRetract__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ReteActionRetract */ "./ReteActionRetract.js");\\n/* harmony import */ var _ReteAction_addRule__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ReteAction_addRule */ "./ReteAction_addRule.js");\\n/* harmony import */ var _ReteAction_removeRule__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ReteAction_removeRule */ "./ReteAction_removeRule.js");\\n/**\\n   Aggregates ReteNet Actions that implement {@link module:ReteAggregateActionDefinitions}\\n   @module ReteActions\\n*/\\n\\n\\n\\n //Action node possible actions:\\n//Stores both performance functions and proposal functions\\n//in the form: { name : {name: "", performFunc : func, propseFunc : func } }\\n\\nvar AggregateActionDefinitions = {};\\n/* harmony default export */ __webpack_exports__["default"] = (AggregateActionDefinitions); //Performance functions take a retenet, and a payload\\n//proposal functions are bound to an action description, and take a token and a retenet\\n//eg: the action asserts a new wme, with an arithmetic action of +2,\\n//the action has the information (+ 2), the incoming token as the base value to add to.\\n//Proposal functions return an object of the form:\\n//{ action: "", payload: {}, (timeData)? }\\n//** @action assert\\n\\nAggregateActionDefinitions[_ReteActionAssert__WEBPACK_IMPORTED_MODULE_0__["default"].name] = _ReteActionAssert__WEBPACK_IMPORTED_MODULE_0__["default"]; //** @action retract\\n\\nAggregateActionDefinitions[_ReteActionRetract__WEBPACK_IMPORTED_MODULE_1__["default"].name] = _ReteActionRetract__WEBPACK_IMPORTED_MODULE_1__["default"]; //** @action AddRule\\n\\nAggregateActionDefinitions[_ReteAction_addRule__WEBPACK_IMPORTED_MODULE_2__["default"].name] = _ReteAction_addRule__WEBPACK_IMPORTED_MODULE_2__["default"]; //** @action removeRule\\n\\nAggregateActionDefinitions[_ReteAction_removeRule__WEBPACK_IMPORTED_MODULE_3__["default"].name] = _ReteAction_removeRule__WEBPACK_IMPORTED_MODULE_3__["default"];\\n\\n//# sourceURL=webpack://Rete/./ReteActions.js?\');\n    },\n    "./ReteActivationAndDeletion.js":\n    /*!**************************************!*\\\n      !*** ./ReteActivationAndDeletion.js ***!\n      \\**************************************/\n\n    /*! exports provided: deleteDescendentsOfToken, removeAlphaMemoryItemsForWME, deleteAllTokensForWME, deleteAllNegJoinResultsForWME, deleteNodeAndAnyUnusedAncestors, leftActivate, rightActivate, alphaNodeActivation, activateIfNegatedJRIsUnblocked */\n    function ReteActivationAndDeletionJs(module, __webpack_exports__, __webpack_require__) {\n      "use strict";\n\n      eval(\'__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deleteDescendentsOfToken", function() { return deleteDescendentsOfToken; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeAlphaMemoryItemsForWME", function() { return removeAlphaMemoryItemsForWME; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deleteAllTokensForWME", function() { return deleteAllTokensForWME; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deleteAllNegJoinResultsForWME", function() { return deleteAllNegJoinResultsForWME; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deleteNodeAndAnyUnusedAncestors", function() { return deleteNodeAndAnyUnusedAncestors; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "leftActivate", function() { return leftActivate; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rightActivate", function() { return rightActivate; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "alphaNodeActivation", function() { return alphaNodeActivation; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "activateIfNegatedJRIsUnblocked", function() { return activateIfNegatedJRIsUnblocked; });\\n/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash */ "lodash");\\n/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);\\n/* harmony import */ var _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ReteDataStructures */ "./ReteDataStructures.js");\\n/* harmony import */ var _ReteComparisonOperators__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ReteComparisonOperators */ "./ReteComparisonOperators.js");\\n/* harmony import */ var _ReteUtilities__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ReteUtilities */ "./ReteUtilities.js");\\n/* harmony import */ var _ReteTestExecution__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ReteTestExecution */ "./ReteTestExecution.js");\\n/**\\n   Functions that describe Activation of ReteNet nodes, and the removal of said nodes\\n   @module ReteActivationAndDeletion\\n   @requires ReteDataStructures\\n   @requires ReteComparisonOperators\\n   @requires ReteUtilities\\n   @requires ReteTestExecution\\n   @requires ReteActions\\n   @requires lodash\\n*/\\n\\n\\n\\n\\n\\n/**\\n   Stores a wme in an alpha memory,\\n   Trigger an alpha memory with a new wme to store\\n   @param alphaMem\\n   @param wme\\n   @function alphaMemoryActivation\\n*/\\n\\nvar alphaMemoryActivation = function alphaMemoryActivation(alphaMem, wme) {\\n  var newItem = new _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["AlphaMemoryItem"](wme, alphaMem);\\n  alphaMem.items.unshift(newItem);\\n  wme.alphaMemoryItems.unshift(newItem);\\n\\n  var alphaMemChildren = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.clone(alphaMem.children);\\n\\n  alphaMemChildren.forEach(function (child) {\\n    return rightActivate(child, wme);\\n  });\\n};\\n/**\\n   Tests a wme against the test in the given node\\n   @param alphaNode\\n   @param wme\\n   @function constantTestNodeActivation\\n*/\\n\\n\\nvar constantTestNodeActivation = function constantTestNodeActivation(alphaNode, wme) {\\n  //test the wme using the constant test in the node\\n  var testResult = false;\\n\\n  if (alphaNode.passThrough) {\\n    testResult = true;\\n  } else {\\n    var wmeFieldValue = _ReteUtilities__WEBPACK_IMPORTED_MODULE_3__["retrieveWMEValueFromDotString"](wme, alphaNode.testField),\\n        value = alphaNode.testValue,\\n        operator = alphaNode.operator;\\n\\n    if (wmeFieldValue === null) {\\n      return false;\\n    }\\n\\n    if (_ReteComparisonOperators__WEBPACK_IMPORTED_MODULE_2__["default"][operator]) {\\n      if (operator !== \\\'EQ\\\' && operator !== \\\'NE\\\') {\\n        testResult = _ReteComparisonOperators__WEBPACK_IMPORTED_MODULE_2__["default"][operator](Number(wmeFieldValue), Number(value));\\n      } else {\\n        testResult = _ReteComparisonOperators__WEBPACK_IMPORTED_MODULE_2__["default"][operator](wmeFieldValue, value);\\n      }\\n    }\\n  }\\n\\n  if (testResult) {\\n    if (alphaNode.outputMemory) {\\n      alphaNodeActivation(alphaNode.outputMemory, wme);\\n    }\\n\\n    alphaNode.children.forEach(function (child) {\\n      return alphaNodeActivation(child, wme);\\n    });\\n  }\\n\\n  return testResult;\\n};\\n/**\\n   Selects whether to store a wme, or test the wme\\n   @param alphaNode\\n   @param wme\\n   @function alphaNodeActivation\\n*/\\n//Switchable activation function for alpha network stuff\\n\\n\\nvar alphaNodeActivation = function alphaNodeActivation(alphaNode, wme) {\\n  if (alphaNode instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["AlphaMemory"]) {\\n    alphaMemoryActivation(alphaNode, wme);\\n  } else if (alphaNode instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["AlphaNode"]) {\\n    return constantTestNodeActivation(alphaNode, wme);\\n  } else {\\n    throw new Error("Unrecognised node:", alphaNode);\\n  }\\n};\\n/**\\n   Stores a token in the beta memory\\n   @param betaMemory\\n   @param token\\n   @function betaMemoryActivation\\n*/\\n\\n\\nvar betaMemoryActivation = function betaMemoryActivation(betaMemory, token) {\\n  //trigger a beta memory to store a new token\\n  //bindings are from the join node, holding results of the NEW binding tests\\n  //old bindings are still in the token, the constructor of Token will combine the two\\n  //sets of bindings\\n  var newToken = token;\\n  betaMemory.items.unshift(newToken);\\n\\n  var betaMemoryChildren = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.clone(betaMemory.children);\\n\\n  betaMemoryChildren.forEach(function (child) {\\n    return leftActivate(child, newToken);\\n  });\\n};\\n/**\\n   Given a new token, compares it to all wmes in the related alpha memory\\n   @param node\\n   @param token\\n   @function joinNodeLeftActivation\\n*/\\n\\n\\nvar joinNodeLeftActivation = function joinNodeLeftActivation(node, token) {\\n  //Trigger a join node with a new token\\n  //will pull all wmes needed from the linked alphaMemory\\n  //If necessary, relink or unlink the\\n  //parent betamemory or alphamemory\\n  if (node.parent.items && node.parent.items.length === 1) {\\n    _ReteUtilities__WEBPACK_IMPORTED_MODULE_3__["relinkToAlphaMemory"](node);\\n\\n    if (node.alphaMemory.items.length === 0) {\\n      //unlink beta memory if alphamemory is empty\\n      var index = node.parent.children.map(function (d) {\\n        return d.id;\\n      }).indexOf(node.id),\\n          unlinked = node.parent.children.splice(index, 1);\\n      node.parent.unlinkedChildren.push(unlinked[0]);\\n    }\\n  } //for each wme in the alpha memory,\\n  //compare using join tests,\\n  //and pass on successful combinations\\n  //to beta memory /negative node children\\n  //to be combined into tokens\\n\\n\\n  node.alphaMemory.items.forEach(function (item) {\\n    var currWME = item.wme,\\n        joinTestResult = Object(_ReteTestExecution__WEBPACK_IMPORTED_MODULE_4__["default"])(node, token, currWME);\\n\\n    if (joinTestResult !== undefined && joinTestResult !== false) {\\n      var newToken = new _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["Token"](token, currWME, node, joinTestResult);\\n      node.items.unshift(newToken);\\n      node.children.forEach(function (child) {\\n        return leftActivate(child, newToken);\\n      });\\n    }\\n  }); //end of looping all wmes in alphamemory\\n};\\n/**\\n   @function joinNodeRightActivation\\n   @param node\\n   @param wme\\n   @purpose given a new wme, compares it against all tokens in the related beta memory\\n*/\\n//Trigger a join node with a new wme\\n//pulling all necessary tokens from the parent as needed\\n\\n\\nvar joinNodeRightActivation = function joinNodeRightActivation(node, wme) {\\n  //relink or unlink as necessary\\n  if (node.alphaMemory.items.length === 1) {\\n    _ReteUtilities__WEBPACK_IMPORTED_MODULE_3__["relinkToBetaMemory"](node);\\n\\n    if (node.parent.items.length === 0) {\\n      var index = node.alphaMemory.children.map(function (d) {\\n        return d.id;\\n      }).indexOf(node.id),\\n          unlinked = node.alphaMemory.children.splice(index, 1);\\n      node.alphaMemory.unlinkedChildren.push(unlinked[0]);\\n    }\\n  } //For all tokens, compare to the new wme,\\n  //pass on successful combinations to betamemory/negative node\\n\\n\\n  node.parent.items.forEach(function (currToken) {\\n    if (currToken.negJoinResults.length > 0 || currToken.nccResults.length > 0) {\\n      return false;\\n    }\\n\\n    var joinTestResult = Object(_ReteTestExecution__WEBPACK_IMPORTED_MODULE_4__["default"])(node, currToken, wme);\\n\\n    if (joinTestResult !== undefined && joinTestResult !== false) {\\n      var newToken = new _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["Token"](currToken, wme, node, joinTestResult);\\n      node.items.unshift(newToken);\\n\\n      var nodeChildren = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.clone(node.children);\\n\\n      nodeChildren.forEach(function (d) {\\n        return leftActivate(d, newToken);\\n      });\\n    }\\n  });\\n};\\n/**\\n   Given a new token, proposes a set of actions\\n   @param actionNode\\n   @param token\\n   @function activateActionNode\\n*/\\n\\n\\nvar actionNodeActivation = function actionNodeActivation(actionNode, token) {\\n  //get the actions the node embodies:\\n  var boundActionFunctions = actionNode.boundActions,\\n      //apply the token to each of the actions\\n  newProposedActions = boundActionFunctions.map(function (d) {\\n    return d(token, actionNode.reteNet);\\n  }),\\n      newProposedActionIds = newProposedActions.map(function (d) {\\n    return d.id;\\n  }); //store the proposed actions in the reteNet.potential actions\\n  //and also tie all the actions that fire together by their ids\\n  //ie: {action:"assert",payload:wme}\\n  //see RDS.ProposedAction for details\\n\\n  newProposedActions.forEach(function (d) {\\n    newProposedActionIds.forEach(function (i) {\\n      d.addParallelAction(i);\\n    });\\n    actionNode.reteNet.proposeAction(d);\\n  });\\n};\\n/**\\n   Selects what node to activate as appropriate, for a new token\\n   @function leftActivate\\n*/\\n\\n\\nvar leftActivate = function leftActivate(node, token, wme, joinTestResults) {\\n  //Utility leftActivation function to call\\n  //whichever specific type is needed\\n  //Construct a new token if supplied the correct\\n  //parameters\\n  if (!(node instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["JoinNode"] || node instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["ActionNode"])) {\\n    token = new _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["Token"](token, wme, node, joinTestResults);\\n  } //owning node is the node going into, rather than coming out of\\n  //Activate the node:\\n  //Essentially a switch of:\\n  //betaMemory, JoinNode, NegativeNode, NCC, PartnerNode, and action\\n\\n\\n  if (node.__isDummy) {//pass on, because this is a test\\n  } else if (node instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["BetaMemory"]) {\\n    betaMemoryActivation(node, token);\\n  } else if (node instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["JoinNode"]) {\\n    joinNodeLeftActivation(node, token);\\n  } else if (node instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["NegativeNode"]) {\\n    negativeNodeLeftActivation(node, token);\\n  } else if (node instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["NCCNode"]) {\\n    nccNodeLeftActivation(node, token);\\n  } else if (node instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["NCCPartnerNode"]) {\\n    nccPartnerNodeLeftActivation(node, token);\\n  } else if (node instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["ActionNode"]) {\\n    actionNodeActivation(node, token);\\n  } else {\\n    throw new Error("Unknown node type leftActivated");\\n  }\\n\\n  return token;\\n};\\n/**\\n   Selects what node to activate, given a new wme\\n   @param node\\n   @param wme\\n   @function rightActivate\\n*/\\n\\n\\nvar rightActivate = function rightActivate(node, wme) {\\n  if (node instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["JoinNode"]) {\\n    joinNodeRightActivation(node, wme);\\n  } else if (node instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["NegativeNode"]) {\\n    negativeNodeRightActivation(node, wme);\\n  } else {\\n    throw new Error("Tried to rightActivate Unrecognised node");\\n  }\\n};\\n/**\\n   Activate a negative node with a new token\\n   @param node\\n   @param newToken\\n   @function negativeNodeLeftActivation\\n*/\\n\\n\\nvar negativeNodeLeftActivation = function negativeNodeLeftActivation(node, newToken) {\\n  //Trigger a negative node from a new token\\n  //brings in bindings, creates a new token as necessary,\\n  //combining bindings too.\\n  //Relink\\n  if (node.items.length === 0) {\\n    _ReteUtilities__WEBPACK_IMPORTED_MODULE_3__["relinkToAlphaMemory"](node);\\n  }\\n\\n  node.items.unshift(newToken);\\n  node.alphaMemory.items.forEach(function (item) {\\n    var currWme = item.wme,\\n        joinTestResult = Object(_ReteTestExecution__WEBPACK_IMPORTED_MODULE_4__["default"])(node, newToken, currWme);\\n\\n    if (joinTestResult) {\\n      //adds itself to the token and\\n      //wme as necessary to block the token\\n      new _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["NegativeJoinResult"](newToken, currWme);\\n    }\\n  }); //if no wmes block the token, pass it on down the network\\n\\n  if (newToken.negJoinResults.length === 0) {\\n    var nodeChildren = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.clone(node.children);\\n\\n    nodeChildren.forEach(function (child) {\\n      return leftActivate(child, newToken);\\n    });\\n  }\\n};\\n/**\\n   Activate a negative node with a new wme\\n   @param node\\n   @param wme\\n   @function negativeNodeRightActivation\\n*/\\n\\n\\nvar negativeNodeRightActivation = function negativeNodeRightActivation(node, wme) {\\n  //trigger a negative node from a new wme,\\n  //getting all tokens stored, comparing to the wme.\\n  //any that the wme blocks, gets an additional negative Join result\\n  //any that don\\\'t get blocked should already have been activated\\n  node.items.forEach(function (currToken) {\\n    if (currToken.negJoinResults.length > 0 || currToken.nccResults.length > 0) {\\n      return false;\\n    }\\n\\n    var joinTestResult = Object(_ReteTestExecution__WEBPACK_IMPORTED_MODULE_4__["default"])(node, currToken, wme);\\n\\n    if (joinTestResult !== undefined && joinTestResult !== false) {\\n      if (currToken.negJoinResults.length === 0) {\\n        //todo: fix this\\n        var invalidatedActions = deleteDescendentsOfToken(currToken);\\n        _ReteUtilities__WEBPACK_IMPORTED_MODULE_3__["cleanupInvalidatedActions"](invalidatedActions);\\n      } //Adds itself to the currToken and wme as\\n      //necessary\\n\\n\\n      new _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["NegativeJoinResult"](currToken, wme);\\n    }\\n  });\\n};\\n/**\\n   Activate a Negated Conjunctive Condition with a new Token\\n   @param nccNode\\n   @param token\\n   @function nccNodeLeftActivation\\n*/\\n\\n\\nvar nccNodeLeftActivation = function nccNodeLeftActivation(nccNode, token) {\\n  //from a new token, trigger the subnetwork?\\n  //Create and store the incoming token from prior join node\\n  if (!(nccNode instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["NCCNode"])) {\\n    throw new Error("nccNodeLeftActivation should be on an NCCNode");\\n  }\\n\\n  if (!(token instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["Token"])) {\\n    throw new Error("nccNodeLeftActivation should be on a token");\\n  }\\n\\n  var newToken = token;\\n  nccNode.items.unshift(newToken); //the partner\\\'s network MUST fire before the nccnode\\n  //hence this. all the new results\\\' in the partners new result buffer,\\n  //are from the same origin as token\\n  //if there are new results to process:\\n\\n  while (nccNode.partner && nccNode.partner.newResultBuffer.length > 0) {\\n    var newResult = nccNode.partner.newResultBuffer.pop(); //add the subnetworks result as a blocking token\\n\\n    newToken.nccResults.unshift(newResult); //set the subnetwork result to have its parent as the new token\\n\\n    newResult.parentToken = newToken;\\n  } //if the new token has no blocking tokens,\\n  //continue on\\n\\n\\n  if (newToken.nccResults.length === 0) {\\n    var nccNodeChildren = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.clone(nccNode.children);\\n\\n    nccNodeChildren.forEach(function (child) {\\n      return leftActivate(child, newToken);\\n    });\\n  }\\n};\\n/**\\n   Activate a Negated Conjunctive Condition\\\'s subnetwork with a new token\\n   @param partner\\n   @param token\\n   @function nccPartnerNodeLeftActivation\\n*/\\n\\n\\nvar nccPartnerNodeLeftActivation = function nccPartnerNodeLeftActivation(partner, token) {\\n  //the nccPartnerNode is activated by a new token from the subnetwork\\n  //figure out who owns this new token from the main (positive) network\\n  //the partner\\\'s ncc\\n  var nccNode = partner.nccNode,\\n      //the token created in left activate, with partner as owner\\n  newToken = token,\\n      ownersToken = token.parentToken,\\n      //the prior token\\n  ownersWme = token.wme,\\n      //the prior wme\\n  owner;\\n\\n  for (var i = 0; i < partner.numberOfConjuncts; i++) {\\n    //go up the owner chain\\n    ownersWme = ownersToken.wme;\\n    ownersToken = ownersToken.parentToken;\\n  } //find an owner in the ncc node\\\'s memory to link to\\n\\n\\n  if (nccNode !== undefined && ownersToken && ownersWme) {\\n    var possibleTokens = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.reject(nccNode.items, function (d) {\\n      return d.parentToken.id !== ownersToken.id || d.wme && d.wme.id !== ownersWme.id;\\n    });\\n\\n    if (possibleTokens.length > 0) {\\n      owner = possibleTokens[0];\\n    }\\n  } //link the owner and the new token\\n\\n\\n  if (owner !== undefined) {\\n    //the necessary owner exists in the nccNode,\\n    //so update it:\\n    owner.nccResults.unshift(newToken);\\n    newToken.parentToken = owner;\\n    var invalidatedActions = deleteDescendentsOfToken(owner);\\n    _ReteUtilities__WEBPACK_IMPORTED_MODULE_3__["cleanupInvalidatedActions"](invalidatedActions);\\n  } else {\\n    //else no owner: add to temp buffer to wait for the ncc node to be activated\\n    partner.newResultBuffer.unshift(newToken);\\n  }\\n};\\n/**\\n   Utility function to activate based on lack of existence of negated join results\\n   @param nJR\\n   @function activateIfNegatedJRIsUnblocked\\n*/\\n\\n\\nvar activateIfNegatedJRIsUnblocked = function activateIfNegatedJRIsUnblocked(nJR) {\\n  var currJoinResult = nJR; //if the negation clears, activate it\\n\\n  if (currJoinResult.owner.negJoinResults.length === 0) {\\n    var owningNodeChildren = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.clone(currJoinResult.owner.owningNode.children);\\n\\n    owningNodeChildren.forEach(function (child) {\\n      return leftActivate(child, currJoinResult.owner);\\n    });\\n  }\\n};\\n/**\\n   To remove a wme from all alpha memories it is stored in\\n   postCondition wme.alphaMemoryItems is empty\\n   @param wme\\n   @function removeAlphaMemoryItemsForWME\\n*/\\n\\n\\nvar removeAlphaMemoryItemsForWME = function removeAlphaMemoryItemsForWME(wme) {\\n  //remove alpha memory items\\n  wme.alphaMemoryItems.forEach(function (item) {\\n    //unlink the alphamemory from the item\\n    item.alphaMemory.items = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.reject(item.alphaMemory.items, function (d) {\\n      return d.id === item.id;\\n    }); //unlink the alphaMemory itself if it is now empty\\n    //will unlink if am.items.length === 0\\n\\n    _ReteUtilities__WEBPACK_IMPORTED_MODULE_3__["unlinkAlphaMemory"](item.alphaMemory); //clear the item\\\'s links\\n\\n    item.alphaMemory = undefined;\\n    item.wme = undefined;\\n  }); //completely clear am items:\\n\\n  wme.alphaMemoryItems = [];\\n};\\n/**\\n   To cleanup all tokens a wme is part of\\n   @param wme\\n   @function deleteAllTokensForWME\\n*/\\n\\n\\nvar deleteAllTokensForWME = function deleteAllTokensForWME(wme) {\\n  var invalidatedActions = new Set(); //For all tokens\\n\\n  while (wme.tokens.length > 0) {\\n    deleteTokenAndDescendents(wme.tokens[0]).forEach(function (d) {\\n      return invalidatedActions.add(d);\\n    });\\n  }\\n\\n  return Array.from(invalidatedActions);\\n};\\n/**\\n   For negative conditions, discount the wme as a block\\n   @param wme\\n   @function deleteAllNegJoinResultsForWME\\n*/\\n\\n\\nvar deleteAllNegJoinResultsForWME = function deleteAllNegJoinResultsForWME(wme) {\\n  //unlink the negative Join results in the owning token\\n  wme.negJoinResults.forEach(function (jr) {\\n    jr.owner.negJoinResults = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.reject(jr.owner.negJoinResults, function (d) {\\n      return d.id === jr.id;\\n    });\\n    activateIfNegatedJRIsUnblocked(jr); //remove internal references:\\n\\n    jr.owner = undefined;\\n    jr.wme = undefined;\\n  }); //completely clear negjoinresults\\n\\n  wme.negJoinResults = [];\\n};\\n/**\\n   To delete any blocked tokens in negative conditions\\n   @param token\\n   @function removeNegJoinResultsForToken\\n*/\\n\\n\\nvar removeNegJoinResultsForToken = function removeNegJoinResultsForToken(token) {\\n  //remove Negative join results\\n  token.negJoinResults.forEach(function (jr) {\\n    jr.wme.negJoinResults = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.reject(jr.wme.negJoinResults, function (d) {\\n      return d.id === jr.id;\\n    }); //clear the references\\n\\n    jr.wme = undefined;\\n    jr.token = undefined;\\n  });\\n  token.negJoinResults = [];\\n};\\n/**\\n   To remove a token from whatever node created it\\n   @param token\\n   @function removeTokenFromNode\\n*/\\n//Now the utility functions for deleteing token:\\n\\n\\nvar removeTokenFromNode = function removeTokenFromNode(token) {\\n  //Deal with if the owning node is NOT an NCC\\n  if (token.owningNode && !(token.owningNode instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["NCCPartnerNode"])) {\\n    //&& (token.owningNode instanceof RDS.AlphaMemory || token.owningNode instanceof RDS.BetaMemory)){\\n    //by removing the token as an element in that node\\n    token.owningNode.items = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.reject(token.owningNode.items, function (d) {\\n      return d.id === token.id;\\n    });\\n  }\\n};\\n/**\\n   To clean a token up, removing it from any WME references\\n   @function removeTokenFromWME\\n*/\\n\\n\\nvar removeTokenFromWME = function removeTokenFromWME(token) {\\n  //remove the token from the wme it is based on\\n  if (token.wme && token.wme.tokens) {\\n    token.wme.tokens = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.reject(token.wme.tokens, function (d) {\\n      return d.id === token.id;\\n    });\\n  }\\n};\\n/**\\n   Cleanup the token from its parents list\\n   @param token\\n   @function removeTokenFromParentToken\\n*/\\n\\n\\nvar removeTokenFromParentToken = function removeTokenFromParentToken(token) {\\n  //Remove the token from it\\\'s parent\\\'s child list\\n  if (token && token.parentToken) {\\n    token.parentToken.children = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.reject(token.parentToken.children, function (d) {\\n      return d.id === token.id;\\n    });\\n  }\\n};\\n/**\\n   Cleanup an unused node and any parent nodes that are also unused once this node is gone.\\n   @param node\\n   @function deleteNodeAndAnyUnusedAncestors\\n*/\\n\\n\\nvar deleteNodeAndAnyUnusedAncestors = function deleteNodeAndAnyUnusedAncestors(node) {\\n  /*\\n    Do a number of things:\\n    clean up tokens stored in a node\\n    remove any reference to the node from a connected alpha\\n    remove any reference to the node from a parent\\n    \\n    +: call recursively on any parent that has no children\\n  */\\n  var invalidatedActions = new Set();\\n\\n  if (node instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["ActionNode"]) {\\n    node.reteNet = null;\\n  } //if NCC, delete partner too\\n\\n\\n  if (node instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["NCCNode"]) {\\n    var tempPartner = node.partner;\\n    node.partner = null;\\n    deleteNodeAndAnyUnusedAncestors(tempPartner).forEach(function (d) {\\n      return invalidatedActions.add(d);\\n    });\\n  } //clean up tokens\\n\\n\\n  if (node instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["BetaMemory"] && node.dummy === undefined || node instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["NegativeNode"] || node instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["NCCNode"] || node instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["JoinNode"]) {\\n    while (node.items.length > 0) {\\n      var curr = node.items.pop();\\n      deleteTokenAndDescendents(curr).forEach(function (d) {\\n        return invalidatedActions.add(d);\\n      });\\n    }\\n  }\\n\\n  if (node instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["NCCPartnerNode"]) {\\n    while (node.newResultBuffer.length > 0) {\\n      var _curr = node.newResultBuffer.pop();\\n\\n      deleteTokenAndDescendents(_curr).forEach(function (d) {\\n        return invalidatedActions.add(d);\\n      });\\n    }\\n  } //clean up any associated alphamemory\\n\\n\\n  if (node.alphaMemory && (node instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["JoinNode"] || node instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["NegativeNode"])) {\\n    node.alphaMemory.children = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.reject(node.alphaMemory.children, function (d) {\\n      return d.id === node.id;\\n    });\\n    node.alphaMemory.unlinkedChildren = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.reject(node.alphaMemory.unlinkedChildren, function (d) {\\n      return d.id === node.id;\\n    });\\n    node.alphaMemory.referenceCount--;\\n\\n    if (node.alphaMemory.referenceCount < 1) {\\n      var tempAlphaMemory = node.alphaMemory;\\n      node.alphaMemory = null;\\n      deleteAlphaNode(tempAlphaMemory).forEach(function (d) {\\n        return invalidatedActions.add(d);\\n      });\\n    }\\n  } //remove the node from its parent\\n\\n\\n  if (node.parent) {\\n    //check the child list:\\n    node.parent.children = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.reject(node.parent.children, function (d) {\\n      return d.id === node.id;\\n    });\\n    node.parent.unlinkedChildren = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.reject(node.parent.unlinkedChildren, function (d) {\\n      return d.id === node.id;\\n    });\\n  } //delete parent node if its got no children\\n\\n\\n  if (node.parent && node.parent.children.length === 0 && node.parent.unlinkedChildren && node.parent.unlinkedChildren.length === 0 && node.parent.dummy === undefined) {\\n    var tempParent = node.parent;\\n    node.parent = null;\\n    deleteNodeAndAnyUnusedAncestors(tempParent).forEach(function (d) {\\n      return invalidatedActions.add(d);\\n    });\\n  } //delete any children to be sure\\n\\n\\n  node.children.forEach(function (d) {\\n    return deleteNodeAndAnyUnusedAncestors(d).forEach(function (e) {\\n      return invalidatedActions.add(e);\\n    });\\n  });\\n  node.unlinkedChildren.forEach(function (d) {\\n    return deleteNodeAndAnyUnusedAncestors(d).forEach(function (e) {\\n      return invalidatedActions.add(e);\\n    });\\n  }); //deallocate memory for none\\n\\n  node.cleanup = true; //schedule for cleanup in the retenet\\n\\n  return Array.from(invalidatedActions);\\n};\\n/**\\n   Simplification of removing children of a token, but not the token itself\\n   @param token\\n   @function deleteDescendentsOfToken\\n*/\\n//utility function to delete all descendents without deleting the token\\n\\n\\nvar deleteDescendentsOfToken = function deleteDescendentsOfToken(token) {\\n  var invalidatedActions = new Set();\\n\\n  while (token.children.length > 0) {\\n    var curr = token.children.pop();\\n    deleteTokenAndDescendents(curr).forEach(function (d) {\\n      return invalidatedActions.add(d);\\n    });\\n  }\\n\\n  token.proposedActions.forEach(function (d) {\\n    return invalidatedActions.add(d);\\n  });\\n  return Array.from(invalidatedActions);\\n};\\n/**\\n   @param token\\n   @function deleteTokenAndDescendents\\n*/\\n\\n\\nvar deleteTokenAndDescendents = function deleteTokenAndDescendents(token) {\\n  /* purpose To remove a token and clean it\\n  delete a token and all the tokens that rely on it\\n  a bit of a frankenstein. Deletes the token,\\n  deletes descendents, but also sets and cleans up\\n  left unlinking of join nodes, AND\\n  activates NCC\\\'s that are no longer blocked\\n  */\\n  var invalidatedActions = new Set(); //Recursive call:\\n\\n  while (token.children.length > 0) {\\n    var curr = token.children.pop();\\n    deleteTokenAndDescendents(curr).forEach(function (d) {\\n      return invalidatedActions.add(d);\\n    });\\n  } //Base Cases:\\n  //remove memory items\\n\\n\\n  removeTokenFromNode(token);\\n  removeTokenFromWME(token);\\n  removeTokenFromParentToken(token);\\n  _ReteUtilities__WEBPACK_IMPORTED_MODULE_3__["ifEmptyBetaMemoryUnlink"](token.owningNode);\\n  _ReteUtilities__WEBPACK_IMPORTED_MODULE_3__["ifEmptyNegNodeUnlink"](token.owningNode, token.id);\\n  removeNegJoinResultsForToken(token);\\n  cleanupNCCResultsInToken(token);\\n  cleanupNCCPartnerOwnedToken(token);\\n\\n  if (token && token.owningNode && token.owningNode instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["NCCPartnerNode"] && token.parentToken.nccResults.length === 0) {\\n    //Activate newly unblocked Token\\n    //todo: should this be nccnode AND/OR negNode?\\n    var nccNodeChildren = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.clone(token.owningNode.nccNode.children);\\n\\n    nccNodeChildren.forEach(function (d) {\\n      return leftActivate(d, token.parentToken);\\n    });\\n  } //get the queued actions linked with the token, and return them for cleanup\\n\\n\\n  token.proposedActions.forEach(function (d) {\\n    return invalidatedActions.add(d);\\n  });\\n  return Array.from(invalidatedActions);\\n};\\n/**\\n   @param token\\n   @function cleanupNCCResultsInToken\\n*/\\n\\n\\nvar cleanupNCCResultsInToken = function cleanupNCCResultsInToken(token) {\\n  //NCCNODE\\n  //for all the nccResult tokens, delete them\\n  token.nccResults.forEach(function (nccR) {\\n    //remove the nccR token from its linked wme\\n    if (nccR.wme) {\\n      nccR.wme.tokens = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.reject(nccR.wme.tokens, function (d) {\\n        return d.id === nccR.id;\\n      });\\n    }\\n\\n    if (nccR.parentToken) {\\n      //remove the token from it\\\'s parent\\n      nccR.parentToken.children = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.reject(nccR.parentToken.children, function (d) {\\n        return d.id === nccR.id;\\n      });\\n    }\\n  }); //clear the nccResults\\n\\n  token.nccResults = [];\\n};\\n/**\\n   @param token\\n   @function cleanupNCCPartnerOwnedToken\\n*/\\n\\n\\nvar cleanupNCCPartnerOwnedToken = function cleanupNCCPartnerOwnedToken(token) {\\n  //NCCPARTNERNODE\\n  if (token.owningNode && token.owningNode instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["NCCPartnerNode"] && token.parentToken) {\\n    //remove from owner.nccResults:\\n    token.parentToken.nccResults = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.reject(token.parentToken.nccResults, function (d) {\\n      return d.id === token.id;\\n    });\\n    token.owningNode.newResultBuffer = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.reject(token.owningNode.newResultBuffer, function (d) {\\n      return d.id === token.id;\\n    });\\n    return true;\\n  }\\n\\n  return false;\\n};\\n\\nvar deleteAlphaNode = function deleteAlphaNode(alphaNode) {\\n  var invalidatedActions = new Set();\\n\\n  if (alphaNode instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["AlphaNode"] && alphaNode.children.length === 0 && alphaNode.outputMemory === null && alphaNode.passThrough === undefined) {\\n    alphaNode.testField = null;\\n    alphaNode.testValue = null;\\n    alphaNode.operator = null;\\n    alphaNode.parent.children = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.reject(alphaNode.parent.children, function (d) {\\n      return d.id === alphaNode.id;\\n    });\\n    var oldParent = alphaNode.parent;\\n    alphaNode.parent = null;\\n    deleteAlphaNode(oldParent).forEach(function (d) {\\n      return invalidatedActions.add(d);\\n    });\\n    alphaNode.cleanup = true;\\n  } else if (alphaNode instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["AlphaMemory"]) {\\n    alphaNode.children.forEach(function (d) {\\n      return deleteNodeAndAnyUnusedAncestors(d);\\n    });\\n    alphaNode.unlinkedChildren.forEach(function (d) {\\n      return deleteNodeAndAnyUnusedAncestors(d);\\n    });\\n    alphaNode.children = [];\\n    alphaNode.unlinkedChildren = [];\\n    var itemIds = alphaNode.items.map(function (d) {\\n      return d.id;\\n    }),\\n        itemWMEs = alphaNode.items.map(function (d) {\\n      return d.wme;\\n    });\\n    itemWMEs.forEach(function (d) {\\n      d.alphaMemoryItems = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.reject(d.alphaMemoryItems, function (e) {\\n        return itemIds.indexOf(e.id) > -1;\\n      });\\n    });\\n    alphaNode.items = [];\\n    var _oldParent = alphaNode.parent;\\n    _oldParent.outputMemory = null;\\n    alphaNode.parent = null;\\n    deleteAlphaNode(_oldParent).forEach(function (d) {\\n      return invalidatedActions.add(d);\\n    });\\n    alphaNode.cleanup = true;\\n  }\\n\\n  return Array.from(invalidatedActions);\\n};\\n\\n\\n\\n//# sourceURL=webpack://Rete/./ReteActivationAndDeletion.js?\');\n    },\n    "./ReteArithmeticActions.js":\n    /*!**********************************!*\\\n      !*** ./ReteArithmeticActions.js ***!\n      \\**********************************/\n\n    /*! exports provided: default */\n    function ReteArithmeticActionsJs(module, __webpack_exports__, __webpack_require__) {\n      "use strict";\n\n      eval("__webpack_require__.r(__webpack_exports__);\\n/**\\n   Defines Arithmetic Actions that the retenet can perform\\n   @module\\n*/\\n\\n/** Add two values */\\nvar plus = function plus(a, b) {\\n  return a + b;\\n},\\n\\n/** Subtract two values */\\nminus = function minus(a, b) {\\n  return a - b;\\n},\\n\\n/** Multiply two values */\\nmult = function mult(a, b) {\\n  return a * b;\\n},\\n\\n/** Divide two values */\\ndiv = function div(a, b) {\\n  return a / b;\\n};\\n\\nvar ArithmeticOperators = {\\n  \'+\': plus,\\n  \'-\': minus,\\n  \'*\': mult,\\n  \'/\': div\\n};\\n/* harmony default export */ __webpack_exports__[\\"default\\"] = (ArithmeticOperators);\\n\\n//# sourceURL=webpack://Rete/./ReteArithmeticActions.js?");\n    },\n    "./ReteClassInterface.js":\n    /*!*******************************!*\\\n      !*** ./ReteClassInterface.js ***!\n      \\*******************************/\n\n    /*! exports provided: default */\n    function ReteClassInterfaceJs(module, __webpack_exports__, __webpack_require__) {\n      "use strict";\n\n      eval(\'__webpack_require__.r(__webpack_exports__);\\n/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash */ "lodash");\\n/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);\\n/* harmony import */ var _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ReteDataStructures */ "./ReteDataStructures.js");\\n/* harmony import */ var _ReteNetworkBuilding__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ReteNetworkBuilding */ "./ReteNetworkBuilding.js");\\n/* harmony import */ var _ReteActivationAndDeletion__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ReteActivationAndDeletion */ "./ReteActivationAndDeletion.js");\\n/* harmony import */ var _ReteUtilities__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ReteUtilities */ "./ReteUtilities.js");\\n/* harmony import */ var _RuleCtors__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./RuleCtors */ "./RuleCtors.js");\\n/* harmony import */ var _ReteActions__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ReteActions */ "./ReteActions.js");\\n/* harmony import */ var _ReteComparisonOperators__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./ReteComparisonOperators */ "./ReteComparisonOperators.js");\\n/* harmony import */ var _ReteArithmeticActions__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./ReteArithmeticActions */ "./ReteArithmeticActions.js");\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\\n\\n/**\\n   Defines a class based ReteNet interface\\n   @module ReteClassInterface\\n   @requires ReteDataStructures\\n   @requires ReteNetworkBuilding\\n   @requires ReteActivationAndDeletion\\n   @requires ReteUtilities\\n   @requires RuleCtors\\n   @requires ReteActions\\n   @requires ReteComparisonOperators\\n   @requires ReteArithmeticActions\\n*/\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n/**\\n   The General controller for a retenet\\n   @constructor\\n   @param actionsToRegister\\n*/\\n\\nvar ReteNet = function ReteNet(actionsToRegister) {\\n  _classCallCheck(this, ReteNet);\\n\\n  if (actionsToRegister === undefined) {\\n    actionsToRegister = [];\\n  }\\n  /**\\n     The starting BetaMemory of the retenet\\n     @member {module:ReteDataStructures.BetaMemory} dummyBetaMemory\\n     @private\\n  */\\n\\n\\n  this.dummyBetaMemory = new _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["BetaMemory"]();\\n  /**\\n     The starting alpha node of the retenet\\n     @member {module:ReteDataStructures.AlphaNode} rootAlpha\\n     @private\\n  */\\n\\n  this.rootAlpha = new _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["AlphaNode"]();\\n  /**\\n     The available actions the retenet can perform\\n     {name: string ,perform : function, propose : function };\\n     @member {Object}\\n     @see {@link module:ReteActions}\\n  */\\n\\n  this.actionFunctions = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.clone(_ReteActions__WEBPACK_IMPORTED_MODULE_6__["default"]);\\n  /** @alias {module:RuleCtors.Rule} */\\n\\n  this.Rule = _RuleCtors__WEBPACK_IMPORTED_MODULE_5__["Rule"];\\n  /** @see {module:ReteComparisonOperators} */\\n\\n  this.ComparisonOperators = _ReteComparisonOperators__WEBPACK_IMPORTED_MODULE_7__["default"];\\n  /** @see {module:ReteArithmeticActions} */\\n\\n  this.ArithmeticOperators = _ReteArithmeticActions__WEBPACK_IMPORTED_MODULE_8__["default"];\\n  /** @see {module:ReteDataStructures.ProposedAction} */\\n\\n  this.ProposedAction = _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["ProposedAction"];\\n  /** @see {module:ReteDataStructures.WME} */\\n\\n  this.WME = _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["WME"];\\n  /** @see {module:ReteDataStructures.Token} */\\n\\n  this.Token = _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["Token"];\\n  /** @see {module:ReteUtilities} */\\n\\n  this.utils = _ReteUtilities__WEBPACK_IMPORTED_MODULE_4__;\\n  /**\\n     All rules loaded into the ReteNet\\n     @member {Object}\\n     @see {@link module:RuleCtors.Rule}\\n  */\\n\\n  this.allRules = {};\\n  /**\\n     Constructed ActionNodes of the ReteNet\\n     @member {Object}\\n     @see {@link module:ReteDataStructures.ActionNode}\\n  */\\n\\n  this.actions = {};\\n  /**\\n     All WMEs that exist in the ReteNet\\n     @member {Object}\\n     @see {@link module:ReteDataStructures.WME}\\n  */\\n\\n  this.allWMEs = {};\\n  /**\\n     All Proposed Actions, from ActionNodes that have fired, indexed by id\\n     could otherwise be known as the conflict set.\\n     @member {Object}\\n     @see {@link module:ReteDataStructure.ProposedActions}\\n  */\\n\\n  this.proposedActions = {};\\n  /**\\n     All Actions that were schedule and then performed\\n     @member {Array}\\n     @see {@link module:ReteDataStructures.ProposedActions}\\n  */\\n\\n  this.enactedActions = [];\\n  /**\\n     All nodes of the ReteNet, enabling inspection\\n     @member {Object}\\n  */\\n\\n  this.allReteNodes = {};\\n  /**\\n     All ReteNodes, indexed by type\\n     todo: make this a weak map?\\n     @member {Object}\\n  */\\n\\n  this.allReteNodesByType = {};\\n  /**\\n     The current time step of the retenet\\n     @member {Int}\\n  */\\n\\n  this.currentTime = 1;\\n  /**\\n     The Actions that have been scheduled\\n     @member {Object}\\n  */\\n\\n  this.schedule = {\\n    assert: [],\\n    retract: [],\\n    modify: []\\n  };\\n  /**\\n     Listeners that have been registered for various occurences\\n     @member {Object}\\n  */\\n\\n  this.listeners = {\\n    "propose": [],\\n    "assert": [],\\n    "retract": [],\\n    "addRule": [],\\n    "removeRule": [],\\n    "schedule": [],\\n    "stepTimeActions": [],\\n    "registerAction": []\\n  }; //Register actions passed in:\\n\\n  actionsToRegister.forEach(function (d) {\\n    this.registerAction(d);\\n  }, this);\\n}; //--------------------\\n//METHODS:\\n//--------------------\\n//Utility to register listeners:\\n\\n/**\\n   Register a function for a retenet occurent\\n   @param {string} name The occurrence type to listen for\\n   @param {function} fn The function to trigger when the occurrence happens\\n   @method\\n*/\\n\\n\\nReteNet.prototype.registerListener = function (name, fn) {\\n  if (this.listeners[name] !== undefined) {\\n    this.listeners[name].push(fn);\\n  }\\n};\\n/**\\n   Trigger all registered listeners for an occurence\\n   @param {string} name The name of the occurrence that happened\\n   @param ...vals The parameters to pass to the listener functions\\n   @method\\n*/\\n\\n\\nReteNet.prototype.fireListener = function (name) {\\n  for (var _len = arguments.length, vals = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\\n    vals[_key - 1] = arguments[_key];\\n  }\\n\\n  if (this.listeners[name] === undefined) {\\n    throw new Error("Unrecognised listener fired: ".concat(name));\\n  } //call the registered functions\\n\\n\\n  this.listeners[name].forEach(function (d) {\\n    return d.apply(void 0, vals);\\n  });\\n};\\n/**\\n   Stores a wme in the retenet, without asserting it.\\n   @param {WME} wme\\n   @private\\n*/\\n\\n\\nReteNet.prototype.storeWME = function (wme) {\\n  this.allWMEs[wme.id] = wme;\\n};\\n/**\\n   Clears the history of actions that have been performed\\n   @method\\n*/\\n\\n\\nReteNet.prototype.clearHistory = function () {\\n  this.enactedActions = [];\\n};\\n/**\\n   Clear the proposed actions list\\n   @method\\n*/\\n\\n\\nReteNet.prototype.clearProposedActions = function () {\\n  this.proposedActions = {};\\n};\\n/**\\n   Assert a wme immediately\\n   @param {WME/Object} wme The wme or data to assert\\n   @return {Int} WME.id\\n   @method\\n*/\\n\\n\\nReteNet.prototype.assertWME = function (wme) {\\n  this.fireListener("assert", wme);\\n\\n  if (!(wme instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["WME"])) {\\n    wme = new _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["WME"](wme, this.currentTime);\\n    this.storeWME(wme);\\n  } //Actually push the wme into the net\\n\\n\\n  _ReteActivationAndDeletion__WEBPACK_IMPORTED_MODULE_3__["alphaNodeActivation"](this.rootAlpha, wme);\\n  return wme.id;\\n};\\n/**\\n   Retract a wme immediately\\n   @param {wme/id} wme The wme object or id to retract\\n   @method\\n*/\\n\\n\\nReteNet.prototype.retractWME = function (wme) {\\n  this.fireListener("retract", wme); //if not given the wme directly\\n\\n  if (!(wme instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["WME"])) {\\n    //if given a wme id\\n    if (Number.isInteger(wme) && this.allWMEs[wme] !== undefined) {\\n      wme = this.allWMEs[wme]; //if given a graph node with a related wme\\n    } else if (wme.wmeId !== undefined && this.allWMEs[wme.wmeId] !== undefined) {\\n      wme = this.allWMEs[wme.wmeId];\\n    } else {\\n      console.log("Unknown:", wme);\\n      throw new Error("Unknown wme to retract");\\n    }\\n  } //Alpha Network retraction:\\n\\n\\n  _ReteActivationAndDeletion__WEBPACK_IMPORTED_MODULE_3__["removeAlphaMemoryItemsForWME"](wme); //Beta Network retraction:\\n\\n  var invalidatedActions = _ReteActivationAndDeletion__WEBPACK_IMPORTED_MODULE_3__["deleteAllTokensForWME"](wme); //Resulting proposed action retraction:\\n\\n  _ReteUtilities__WEBPACK_IMPORTED_MODULE_4__["cleanupInvalidatedActions"](invalidatedActions); //Negative Node updates\\n\\n  _ReteActivationAndDeletion__WEBPACK_IMPORTED_MODULE_3__["deleteAllNegJoinResultsForWME"](wme); //Record when the wme was retracted\\n\\n  wme.lifeTime[1] = this.currentTime; //Remove it from the fact base\\n\\n  delete this.allWMEs[wme.id]; //And give it to the user if they want it\\n\\n  return wme;\\n};\\n/**\\n   Retract, change, and then assert some data\\n   @param {WME/id} wme The wme to retract\\n   @param {function} modifyFunction The function that changes the data of the wme\\n   @method\\n*/\\n\\n\\nReteNet.prototype.modifyWME = function (wme, modifyFunction) {\\n  var retractedWME = this.retractWME(wme),\\n      data = retractedWME.data,\\n      modifiedData = modifyFunction(data);\\n\\n  if (modifiedData === undefined || modifiedData === null) {\\n    throw new Error("Modify function must return the new data");\\n  }\\n\\n  return this.assertWME(modifiedData);\\n};\\n/**\\n   Propose an action, typically from an action node\\n   @param {module:ReteDataStructures.ProposedAction} action\\n   @method\\n*/\\n\\n\\nReteNet.prototype.proposeAction = function (action) {\\n  var _this = this;\\n\\n  this.fireListener("propose", action);\\n\\n  if (action instanceof Array) {\\n    action.forEach(function (d) {\\n      return _this.proposeAction(d);\\n    });\\n    return;\\n  }\\n\\n  if (this.proposedActions[action.id] !== undefined) {\\n    throw new Error("Proposing a duplicate action");\\n  }\\n\\n  this.proposedActions[action.id] = action;\\n};\\n\\nReteNet.prototype.unproposeAction = function (actionId) {\\n  if (this.proposedActions[actionId] !== undefined) {\\n    this.proposedActions[actionId].removeFromParentToken();\\n    delete this.proposedActions[actionId];\\n  }\\n};\\n/**\\n   Schedule an action by it\\\'s ID, ALSO scheduling any parallel actions\\n   @param  {module:ReteDataStructures.ProposedAction|Int} actionId The action to propose\\n   @method\\n*/\\n\\n\\nReteNet.prototype.scheduleAction = function (actionId) {\\n  var _this2 = this;\\n\\n  this.fireListener("schedule", actionId);\\n\\n  if (actionId instanceof this.ProposedAction) {\\n    this.scheduleAction(actionId.id);\\n    return;\\n  }\\n\\n  if (this.proposedActions[actionId] === undefined) {\\n    throw new Error("Invalid action specified: " + actionId);\\n  }\\n\\n  var action = this.proposedActions[actionId],\\n      parallelActions = action.getParallelActions().map(function (d) {\\n    return _this2.proposedActions[d];\\n  });\\n  this.addToSchedule(action);\\n  parallelActions.forEach(function (d) {\\n    return _this2.addToSchedule(d);\\n  });\\n  return this;\\n};\\n/**\\n   Internal method to add to the schedule\\n   @param {module:ReteDataStructures.ProposedAction} action\\n   @method\\n   @private\\n*/\\n\\n\\nReteNet.prototype.addToSchedule = function (action) {\\n  if (action.actionType === undefined || action.payload === undefined || action.timing === undefined) {\\n    throw new Error("Scheduling action failure");\\n  }\\n\\n  if (this.schedule[action.actionType] === undefined) {\\n    this.schedule[action.actionType] = [];\\n  }\\n\\n  var performTime = this.currentTime + action.timing.performOffset;\\n\\n  if (this.schedule[action.actionType][performTime] === undefined) {\\n    this.schedule[action.actionType][performTime] = [];\\n  }\\n\\n  this.schedule[action.actionType][performTime].push(action); //Remove it from retenet\\\'s proposed actions:\\n\\n  this.unproposeAction(action.id);\\n};\\n/**\\n   Step Time forward. actions should be scheduled BEFORE CALLING STEP TIME.\\n   @method\\n   @returns {Array} An array of the effects of this timestep\\n*/\\n\\n\\nReteNet.prototype.stepTime = function () {\\n  var _this3 = this;\\n\\n  //get all actions scheduled at the current timepoint\\n  var actions = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.values(this.schedule),\\n      actionsForTimePoint = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.reject(lodash__WEBPACK_IMPORTED_MODULE_0___default.a.flatten(actions.map(function (d) {\\n    return d[_this3.currentTime];\\n  })), function (d) {\\n    return d === undefined;\\n  }); //todo : group by tags:\\n  //Sort by priority\\n\\n\\n  actionsForTimePoint.sort(function (a, b) {\\n    return b.priority - a.priority;\\n  });\\n  this.fireListener(\\\'stepTimeActions\\\', actionsForTimePoint); //perform those actions, storing objects describing the changes\\n\\n  var changes = actionsForTimePoint.map(function (d) {\\n    var performanceFunction = this.actionFunctions[d.actionType].perform,\\n        effects = performanceFunction(d, this);\\n    this.enactedActions.push(d);\\n    return effects;\\n  }, this); //cleanup invalidated actions\\n\\n  lodash__WEBPACK_IMPORTED_MODULE_0___default.a.values(this.proposedActions).forEach(function (d) {\\n    if (d.timing.invalidateTime <= this.currentTime) {\\n      this.unproposeAction(d.id);\\n    }\\n  }, this);\\n\\n  this.currentTime++;\\n  return changes;\\n};\\n/**\\n   Add a rule to the retenet, auto converting to correct format if necessary, returning [ReteNet,{@link{module:ReteDataStructures.ActionNode}]\\n   @param {Array | int | module:RuleCtors.Rule} ruleId The rule/rules to add\\n   @param {Object} components An object to lookup components of rules in\\n   @method\\n   @returns {Array}\\n   \\n*/\\n\\n\\nReteNet.prototype.addRule = function (ruleId, components) {\\n  var _this4 = this;\\n\\n  this.fireListener("addRule", components);\\n\\n  if (ruleId instanceof Array) {\\n    return ruleId.map(function (d) {\\n      return _this4.addRule(d, components);\\n    });\\n  }\\n\\n  if (ruleId instanceof this.Rule) {\\n    var convertedComponents = this.convertRulesToComponents(ruleId);\\n    return this.addRule(ruleId.id, convertedComponents);\\n  }\\n\\n  if (!Number.isInteger(ruleId) || components[ruleId] === undefined) {\\n    throw new Error("Unrecognised rule id specified");\\n  } //-----------\\n  //Add a single rule:\\n\\n\\n  var rule = components[ruleId],\\n      ruleLinks = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.toPairs(rule.linkedNodes),\\n      //TODO: support rules as conditions by flattening the conditions repeatedly\\n  conditions = ruleLinks.filter(function (d) {\\n    return /^condition/.test(d[1]);\\n  }).map(function (d) {\\n    return components[d[0]];\\n  }),\\n      //build network with a dummy node for the parent\\n  finalMemoryNode = Object(_ReteNetworkBuilding__WEBPACK_IMPORTED_MODULE_2__["default"])(this.dummyBetaMemory, conditions, this.rootAlpha, components, this),\\n      //Get the action descriptions that are triggered by the rule:\\n  //TODO: support rules as actions by repeatedly flattening\\n  actionDescriptions = ruleLinks.filter(function (d) {\\n    return /^action/.test(d[1]);\\n  }).map(function (d) {\\n    return components[d[0]];\\n  }),\\n      //Bind proposalFuncs with actionDescriptions\\n  boundActionDescriptions = actionDescriptions.map(function (d) {\\n    if (this.actionFunctions[d.tags.actionType] === undefined) {\\n      throw new Error("Unrecognised action type");\\n    }\\n\\n    return lodash__WEBPACK_IMPORTED_MODULE_0___default.a.bind(this.actionFunctions[d.tags.actionType].propose, d);\\n  }, this),\\n      //Create the action, with the bound action functions\\n  ruleAction = new _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["ActionNode"](finalMemoryNode, actionDescriptions, boundActionDescriptions, rule.name, this); //Add the bound actions into the action node:\\n\\n\\n  ruleAction.ruleId = rule.id;\\n  ruleAction.boundActions = boundActionDescriptions;\\n  this.actions[ruleAction.ruleId] = ruleAction;\\n  this.allRules[ruleAction.ruleId] = rule;\\n  return [this, ruleAction];\\n};\\n/**\\n   Remove rule(s) from the retenet, bottom up from {@link:module.ReteDataStructures.ActionNode}\\n   @param {module:ReteDataStructures.ActionNode | Array} rule The rule(s) to remove from the net\\n   @method\\n*/\\n\\n\\nReteNet.prototype.removeRule = function (rule) {\\n  var _this5 = this;\\n\\n  this.fireListener("removeRule", rule);\\n\\n  if (rule instanceof Array) {\\n    rule.forEach(function (d) {\\n      return _this5.removeRule(d);\\n    });\\n    return;\\n  } //delete from bottom up\\n\\n\\n  var action = rule instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["ActionNode"] ? rule : this.actions[rule.id],\\n      invalidatedActions = _ReteActivationAndDeletion__WEBPACK_IMPORTED_MODULE_3__["deleteNodeAndAnyUnusedAncestors"](action);\\n  _ReteUtilities__WEBPACK_IMPORTED_MODULE_4__["cleanupInvalidatedActions"](invalidatedActions); //delete from the allrules record\\n\\n  if (this.allRules[action.ruleId] !== undefined) {\\n    delete this.allRules[action.ruleId];\\n  } //Remove all nodes scheduled for cleanup\\n\\n\\n  lodash__WEBPACK_IMPORTED_MODULE_0___default.a.keys(this.allReteNodes).forEach(function (d) {\\n    if (this.allReteNodes[d].cleanup === true) {\\n      var currNode = this.allReteNodes[d];\\n      delete this.allReteNodesByType[currNode.type][currNode.id];\\n      delete this.allReteNodes[d];\\n    }\\n  }, this);\\n\\n  if (this.actions[rule.id] !== undefined) {\\n    delete this.actions[rule.id];\\n  }\\n};\\n/**\\n   register a join action proposal and performance function\\n   @param {{name : string, propose : function, perform : function}} actionObj\\n   @method\\n   @see module:ReteActions\\n*/\\n\\n\\nReteNet.prototype.registerAction = function (actionObj) {\\n  this.fireListener(\\\'registerAction\\\', actionObj);\\n\\n  if (actionObj.name === undefined || actionObj.perform === undefined || actionObj.propose === undefined) {\\n    throw new Error("Action Registration Failure");\\n  }\\n\\n  if (this.actionFunctions[actionObj.name] !== undefined) {\\n    throw new Error("Registration Attempt for existing Action");\\n  }\\n\\n  this.actionFunctions[actionObj.name] = actionObj;\\n};\\n/**\\n   Store a node in the appropriate members of the ReteNet\\n   @param {module:ReteDataStructures.ReteNode} node\\n   @method\\n   @private\\n*/\\n\\n\\nReteNet.prototype.storeNode = function (node) {\\n  this.allReteNodes[node.id] = node;\\n\\n  if (this.allReteNodesByType[node.type] === undefined) {\\n    this.allReteNodesByType[node.type] = {};\\n  }\\n\\n  this.allReteNodesByType[node.type][node.id] = node;\\n};\\n/**\\n   Converts rules to an object of their components for easy addition\\n   @param {module:RuleCtors.Rule | Array} rules\\n   @method\\n   @return {Object}\\n*/\\n\\n\\nReteNet.prototype.convertRulesToComponents = function (rules) {\\n  if (!(rules instanceof Array)) {\\n    rules = [rules];\\n  }\\n\\n  var actions = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.flatten(rules.map(function (d) {\\n    return lodash__WEBPACK_IMPORTED_MODULE_0___default.a.values(d.actions);\\n  })),\\n      conditions = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.flatten(rules.map(function (d) {\\n    return lodash__WEBPACK_IMPORTED_MODULE_0___default.a.values(d.conditions);\\n  })),\\n      all = actions.concat(conditions).concat(rules),\\n      components = all.reduce(function (m, v) {\\n    m[v.id] = v;\\n    return m;\\n  }, {}); //convert to linkednode style for every component:\\n\\n\\n  lodash__WEBPACK_IMPORTED_MODULE_0___default.a.values(components).forEach(function (d) {\\n    d.linkedNodes = {}; //add actions\\n\\n    d.linkedNodes = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.keys(d.actions).reduce(function (m, v) {\\n      m[v] = "action";\\n      return m;\\n    }, d.linkedNodes); //add conditions\\n\\n    d.linkedNodes = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.keys(d.conditions).reduce(function (m, v) {\\n      m[v] = \\\'condition\\\';\\n      return m;\\n    }, d.linkedNodes);\\n  });\\n\\n  return components;\\n};\\n/**\\n   Clean up\\n*/\\n\\n\\nReteNet.prototype.cleanup = function () {\\n  var _this6 = this;\\n\\n  //retract all wmes\\n  lodash__WEBPACK_IMPORTED_MODULE_0___default.a.values(this.allWMEs).forEach(function (d) {\\n    return _this6.retractWME(d);\\n  });\\n\\n  this.allWMEs = {}; //remove all rules\\n\\n  this.removeRule(lodash__WEBPACK_IMPORTED_MODULE_0___default.a.values(this.allRules));\\n};\\n\\n/* harmony default export */ __webpack_exports__["default"] = (ReteNet);\\n\\n//# sourceURL=webpack://Rete/./ReteClassInterface.js?\');\n    },\n    "./ReteComparisonOperators.js":\n    /*!************************************!*\\\n      !*** ./ReteComparisonOperators.js ***!\n      \\************************************/\n\n    /*! exports provided: default */\n    function ReteComparisonOperatorsJs(module, __webpack_exports__, __webpack_require__) {\n      "use strict";\n\n      eval(\'__webpack_require__.r(__webpack_exports__);\\n/**\\n   To define the possible operators available for constant test nodes\\n   @module ReteComparisonOperators\\n*/\\n//Define an object of comparisons able to\\n//be used in constant tests\\n//See general utils file for converting to string\\n//TODO: These can be changed to their actual representations, similar to reteArithActions\\nvar ConstantTestOperators = {\\n  "EQ": function EQ(a, b) {\\n    return a === b;\\n  },\\n  "LT": function LT(a, b) {\\n    return a < b;\\n  },\\n  "GT": function GT(a, b) {\\n    return a > b;\\n  },\\n  "LTE": function LTE(a, b) {\\n    return a <= b;\\n  },\\n  "GTE": function GTE(a, b) {\\n    return a >= b;\\n  },\\n  "NE": function NE(a, b) {\\n    return a !== b;\\n  },\\n  "MATCH": function MATCH(a, b) {\\n    var regex = new RegExp(b);\\n    return regex.test(a);\\n  }\\n};\\nConstantTestOperators[\\\'===\\\'] = ConstantTestOperators.EQ;\\nConstantTestOperators[\\\'<\\\'] = ConstantTestOperators.LT;\\nConstantTestOperators[\\\'>\\\'] = ConstantTestOperators.GT;\\nConstantTestOperators[\\\'<=\\\'] = ConstantTestOperators.LTE;\\nConstantTestOperators[\\\'>=\\\'] = ConstantTestOperators.GTE;\\nConstantTestOperators[\\\'!==\\\'] = ConstantTestOperators.NE;\\nConstantTestOperators[\\\'~=\\\'] = ConstantTestOperators.MATCH;\\n/* harmony default export */ __webpack_exports__["default"] = (ConstantTestOperators);\\n\\n//# sourceURL=webpack://Rete/./ReteComparisonOperators.js?\');\n    },\n    "./ReteDataStructures.js":\n    /*!*******************************!*\\\n      !*** ./ReteDataStructures.js ***!\n      \\*******************************/\n\n    /*! exports provided: WME, Token, AlphaMemory, AlphaMemoryItem, AlphaNode, ReteNode, BetaMemory, JoinNode, NegativeJoinResult, NegativeNode, NCCNode, NCCPartnerNode, ActionNode, ProposedAction */\n    function ReteDataStructuresJs(module, __webpack_exports__, __webpack_require__) {\n      "use strict";\n\n      eval(\'__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WME", function() { return WME; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Token", function() { return Token; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AlphaMemory", function() { return AlphaMemory; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AlphaMemoryItem", function() { return AlphaMemoryItem; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AlphaNode", function() { return AlphaNode; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ReteNode", function() { return ReteNode; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BetaMemory", function() { return BetaMemory; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "JoinNode", function() { return JoinNode; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NegativeJoinResult", function() { return NegativeJoinResult; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NegativeNode", function() { return NegativeNode; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NCCNode", function() { return NCCNode; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NCCPartnerNode", function() { return NCCPartnerNode; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ActionNode", function() { return ActionNode; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ProposedAction", function() { return ProposedAction; });\\n/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash */ "lodash");\\n/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);\\nfunction _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\\n\\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\\n\\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\\n\\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\\n\\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\\\'t been initialised - super() hasn\\\'t been called"); } return self; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\\n\\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\\n\\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\\n\\n/**\\n   Defines the data structures required for the Net\\n   @module ReteDataStructures\\n   @requires lodash\\n*/\\n\\nvar nextId = 0;\\n/**\\n   Describes a queued, but not yet performed, action\\n   @param reteNet\\n   @param type\\n   @param strId The \\\'name\\\' of the action, Rule.newAction(type,name...)\\n   @param payload\\n   @param token\\n   @param proposeTime\\n   @param timingObj\\n   @param priority\\n   @param tags\\n   @class ProposedAction\\n   queue/invalidate time absolute,\\n   assertTime/retractTime relative to when action is enacted\\n*/\\n\\nvar ProposedAction =\\n/*#__PURE__*/\\nfunction () {\\n  function ProposedAction(reteNet, type, strId, payload, token, proposeTime, timingObj, priority, tags) {\\n    _classCallCheck(this, ProposedAction);\\n\\n    this.id = nextId++;\\n    this.actionStringIdentifier = strId;\\n    this.type = "ProposedAction";\\n    this.reteNet = reteNet;\\n    this.actionType = type; //ie: "assert","retract","perform"...\\n\\n    this.payload = payload; //ie" : {a:3,b:4}...\\n\\n    this.token = token; //Source Token that spawned this action\\n\\n    this.timing = {\\n      //when PA is created\\n      proposeTime: proposeTime || 0,\\n      //when it is invalidated and removed from the proposal set\\n      invalidateTime: proposeTime + (timingObj ? timingObj.invalidateOffset : 0),\\n      //When the happens after it is scheduled (currentTime + pOffset)\\n      performOffset: timingObj ? timingObj.performOffset : 0,\\n      //When the action is scheduled to reverse( currentTime+pOffset+upOffset)\\n      unperformOffset: timingObj ? timingObj.unperformOffset : 0\\n    };\\n    this.priority = priority || 0;\\n    this.tags = tags || {};\\n    this.parallelActions = new Set(); //todo: possibly include metrics for selection of actions?\\n    //todo: check for circular reference cleanup\\n    //update Token:\\n\\n    if (this.token && this.token.proposedActions) {\\n      this.token.proposedActions.push(this);\\n    }\\n  }\\n\\n  _createClass(ProposedAction, [{\\n    key: "addParallelAction",\\n    value: function addParallelAction(anActionId) {\\n      if (anActionId !== this.id && this.parallelActions.indexOf(anActionId) === -1) {\\n        this.parallelActions.add(anActionId);\\n      }\\n    }\\n  }, {\\n    key: "getParallelActions",\\n    value: function getParallelActions() {\\n      return Array.from(this.parallelActions);\\n    }\\n  }, {\\n    key: "removeFromParentToken",\\n    value: function removeFromParentToken() {\\n      var _this = this;\\n\\n      if (this.token !== undefined && this.token !== null) {\\n        this.token.proposedActions = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.reject(this.token.proposedActions, function (d) {\\n          return d.id === _this.id;\\n        });\\n      }\\n    }\\n  }]);\\n\\n  return ProposedAction;\\n}();\\n/**\\n   Stores facts in the rete net\\n   @param data\\n   @param assertTime\\n   @class WME\\n*/\\n\\n\\nvar WME = function WME(data, assertTime) {\\n  _classCallCheck(this, WME);\\n\\n  this.id = nextId++;\\n  this.type = "WME";\\n  this.data = data; //The lifetime of the wme. Asserted at time lifeTime[0],\\n  //retracted at time lifeTime[1]:\\n\\n  if (assertTime === undefined) {\\n    assertTime = 0;\\n  }\\n\\n  this.lifeTime = [assertTime]; //Alpha memories the wme is part of\\n\\n  this.alphaMemoryItems = []; //Tokens the wme is part of\\n\\n  this.tokens = []; //Tokens this wme is blocking\\n\\n  this.negJoinResults = [];\\n};\\n/**\\n   Represents intermediate results in the beta network\\n   @param parentToken\\n   @param wme\\n   @param owningNode\\n   @param bindings\\n   @class Token\\n*/\\n\\n\\nvar Token = function Token(parentToken, wme, owningNode, bindings) {\\n  _classCallCheck(this, Token);\\n\\n  this.id = nextId++;\\n  this.type = "Token"; //bindings are updated as the token progresses\\n\\n  this.parentToken = parentToken; //ie:owner\\n\\n  this.wme = wme;\\n  this.owningNode = owningNode;\\n  this.children = []; //list of tokens\\n\\n  this.negJoinResults = []; //list of blocking NegativeJoinResults\\n\\n  this.nccResults = []; //list of blocking Tokens\\n\\n  this.proposedActions = []; //current proposed actions\\n\\n  if (this.parentToken) {\\n    this.parentToken.children.unshift(this);\\n  }\\n\\n  if (this.wme && this.wme.tokens) {\\n    this.wme.tokens.unshift(this);\\n  } //copy over bindings from parent,\\n  //then copy in new bindings\\n\\n\\n  this.bindings = {};\\n\\n  if (this.parentToken && this.parentToken.bindings) {\\n    lodash__WEBPACK_IMPORTED_MODULE_0___default.a.keys(this.parentToken.bindings).forEach(function (d) {\\n      this.bindings[d] = this.parentToken.bindings[d];\\n    }, this);\\n  }\\n\\n  lodash__WEBPACK_IMPORTED_MODULE_0___default.a.keys(bindings).forEach(function (d) {\\n    this.bindings[d] = bindings[d];\\n  }, this);\\n}; //------------------------------\\n\\n/**\\n   A Pairing of a wme with an alpha memory it resides in\\n   @param wme\\n   @param alphaMem\\n   @class AlphaMemoryItem\\n*/\\n//Utility storage of wme and its alphaMemory together\\n//used in alphamemory and WME\\n\\n\\nvar AlphaMemoryItem = function AlphaMemoryItem(wme, alphaMem) {\\n  _classCallCheck(this, AlphaMemoryItem);\\n\\n  this.id = nextId++;\\n  this.type = "AlphaMemoryItem";\\n  this.wme = wme;\\n  this.alphaMemory = alphaMem;\\n};\\n/**\\n   A node to perform constant tests on newly asserted WMEs\\n   constantTest = {field: string, value: string ,operator: string};\\n   @param parent\\n   @param constantTestSpec\\n   @class AlphaNode\\n*/\\n\\n\\nvar AlphaNode = function AlphaNode(parent, constantTestSpec) {\\n  _classCallCheck(this, AlphaNode);\\n\\n  this.id = nextId++;\\n  this.type = "AlphaNode";\\n  this.parent = parent;\\n\\n  if (this.parent && this.parent.children) {\\n    this.parent.children.unshift(this);\\n  }\\n\\n  this.children = [];\\n  this.outputMemory = undefined;\\n\\n  if (constantTestSpec) {\\n    this.testField = constantTestSpec.field;\\n    this.testValue = constantTestSpec.value;\\n    this.operator = constantTestSpec.operator;\\n  } else {\\n    this.passThrough = true;\\n  }\\n};\\n/**\\n   To store wmes that have passed through constant tests\\n   @param parent\\n   @class AlphaMemory\\n*/\\n\\n\\nvar AlphaMemory = function AlphaMemory(parent) {\\n  _classCallCheck(this, AlphaMemory);\\n\\n  this.id = nextId++;\\n  this.type = "AlphaMemory";\\n  this.items = [];\\n  this.parent = parent; //If adding to a node other than a test node,\\n\\n  if (this.parent && !(this.parent instanceof AlphaNode)) {\\n    //add to children\\n    throw new Error("Adding alpha memory as child of not a test");\\n  } else if (this.parent && this.parent instanceof AlphaNode && this.parent.outputMemory === undefined) {\\n    //if an alphanode, set the ouputmemory field\\n    this.parent.outputMemory = this;\\n  } else {\\n    throw new Error("trying to create an alpha memory for a node that already has one");\\n  }\\n\\n  this.children = [];\\n  this.unlinkedChildren = [];\\n  this.referenceCount = 0;\\n};\\n/**\\n   Provides a base definition of a node in the rete network\\n   @class ReteNode\\n\\n*/\\n//Base node for the beta network\\n\\n\\nvar ReteNode = function ReteNode(parent) {\\n  _classCallCheck(this, ReteNode);\\n\\n  this.id = nextId++;\\n  this.type = "ReteNode";\\n  this.children = [];\\n  this.unlinkedChildren = [];\\n  this.parent = parent;\\n\\n  if (this.parent && this.parent.children) {\\n    this.parent.children.unshift(this);\\n  }\\n};\\n/**\\n   A Node to store tokens in the rete network\\n   @param parent\\n   @class BetaMemory\\n   @augments ReteNode\\n*/\\n\\n\\nvar BetaMemory =\\n/*#__PURE__*/\\nfunction (_ReteNode) {\\n  _inherits(BetaMemory, _ReteNode);\\n\\n  function BetaMemory(parent) {\\n    var _this2;\\n\\n    _classCallCheck(this, BetaMemory);\\n\\n    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(BetaMemory).call(this, parent));\\n    _this2.type = "BetaMemory";\\n    _this2.items = [];\\n\\n    if (parent === undefined) {\\n      _this2.dummy = true;\\n\\n      _this2.items.push(new Token());\\n\\n      _this2.items[0].owningNode = _assertThisInitialized(_assertThisInitialized(_this2));\\n    }\\n\\n    return _this2;\\n  }\\n\\n  return BetaMemory;\\n}(ReteNode);\\n/**\\n   To combine tokens and wmes, according to binding tests\\n   @class JoinNode\\n   @augments ReteNode\\n*/\\n\\n\\nvar JoinNode =\\n/*#__PURE__*/\\nfunction (_ReteNode2) {\\n  _inherits(JoinNode, _ReteNode2);\\n\\n  function JoinNode(parent, alphaMemory, tests) {\\n    var _this3;\\n\\n    _classCallCheck(this, JoinNode);\\n\\n    //Join Node combines tokens with wmes\\n    //tests are the binding tuples from a condition\\n    _this3 = _possibleConstructorReturn(this, _getPrototypeOf(JoinNode).call(this, parent));\\n    _this3.type = "JoinNode";\\n    _this3.alphaMemory = alphaMemory;\\n\\n    if (tests) {\\n      _this3.tests = tests;\\n    } else {\\n      _this3.tests = [];\\n    }\\n\\n    if (_this3.alphaMemory && _this3.alphaMemory.children) {\\n      _this3.alphaMemory.children.unshift(_assertThisInitialized(_assertThisInitialized(_this3)));\\n\\n      _this3.alphaMemory.referenceCount += 1;\\n    }\\n\\n    _this3.nearestAncestor = null;\\n    _this3.items = [];\\n    return _this3;\\n  }\\n\\n  return JoinNode;\\n}(ReteNode);\\n/**\\n   A Node which, when activated, will cause the effects a rule describes\\n   @param parent\\n   @param actionDescriptions\\n   @param boundActions\\n   @param ruleName\\n   @param reteNet\\n   @augments ReteNode\\n   @class ActionNode\\n*/\\n\\n\\nvar ActionNode =\\n/*#__PURE__*/\\nfunction (_ReteNode3) {\\n  _inherits(ActionNode, _ReteNode3);\\n\\n  function ActionNode(parent, actionDescriptions, boundActions, ruleName, reteNet) {\\n    var _this4;\\n\\n    _classCallCheck(this, ActionNode);\\n\\n    //Container object for a general graphnode action description\\n    _this4 = _possibleConstructorReturn(this, _getPrototypeOf(ActionNode).call(this, parent));\\n    _this4.type = "ActionNode";\\n    _this4.name = ruleName;\\n    _this4.actionDescriptions = actionDescriptions; //All of the effects this action node triggers together:\\n\\n    _this4.boundActions = boundActions; //reference to retenet, to allow storage of results of firing:\\n\\n    _this4.reteNet = reteNet;\\n    return _this4;\\n  }\\n\\n  return ActionNode;\\n}(ReteNode);\\n/**\\n   To Store the combination of a token and a wme that blocks it from progressing through the network\\n   @param owner the token\\n   @param wme the wme\\n   @class NegativeJoinResult\\n*/\\n\\n\\nvar NegativeJoinResult = function NegativeJoinResult(owner, wme) {\\n  _classCallCheck(this, NegativeJoinResult);\\n\\n  //Storage for a token blocked by a wme\\n  //Updates the owner token and wme as part of its construction\\n  this.id = nextId++;\\n  this.type = "Negative Join Result";\\n  this.owner = owner;\\n\\n  if (this.owner) {\\n    this.owner.negJoinResults.unshift(this);\\n  }\\n\\n  this.wme = wme;\\n\\n  if (this.wme) {\\n    this.wme.negJoinResults.unshift(this);\\n  }\\n};\\n/**\\n   A Node that tests for the abscence of particular wmes\\n   @param parent\\n   @param alphaMemory\\n   @param tests\\n   @class NegativeNode\\n   @augments ReteNode\\n*/\\n\\n\\nvar NegativeNode =\\n/*#__PURE__*/\\nfunction (_ReteNode4) {\\n  _inherits(NegativeNode, _ReteNode4);\\n\\n  function NegativeNode(parent, alphaMemory, tests) {\\n    var _this5;\\n\\n    _classCallCheck(this, NegativeNode);\\n\\n    _this5 = _possibleConstructorReturn(this, _getPrototypeOf(NegativeNode).call(this, parent));\\n    _this5.type = "Negative Node";\\n    _this5.items = [];\\n    _this5.alphaMemory = alphaMemory;\\n\\n    if (_this5.alphaMemory) {\\n      _this5.alphaMemory.referenceCount++;\\n\\n      _this5.alphaMemory.children.unshift(_assertThisInitialized(_assertThisInitialized(_this5)));\\n    }\\n\\n    _this5.tests = tests || [];\\n    _this5.nearestAncestor = null;\\n    return _this5;\\n  }\\n\\n  return NegativeNode;\\n}(ReteNode);\\n/**\\n   The generalisation of the negative node to multiple conditions, forms the leaf of a subnetwork\\n   @param parent\\n   @class NCCNode\\n   @augments ReteNode\\n   @see {@link NCCondition}\\n*/\\n\\n\\nvar NCCNode =\\n/*#__PURE__*/\\nfunction (_ReteNode5) {\\n  _inherits(NCCNode, _ReteNode5);\\n\\n  function NCCNode(parent) {\\n    var _this6;\\n\\n    _classCallCheck(this, NCCNode);\\n\\n    //NCC : gates token progression based on a subnetwork\\n    //don\\\'t pass parent in so you can PUSH instead of SHIFT\\n    _this6 = _possibleConstructorReturn(this, _getPrototypeOf(NCCNode).call(this));\\n    _this6.type = "NCCNode";\\n    _this6.parent = parent;\\n\\n    if (_this6.parent && _this6.parent.children) {\\n      _this6.parent.children.push(_assertThisInitialized(_assertThisInitialized(_this6)));\\n    }\\n    /**\\n       @type {Array.<RDS.Token>}\\n    */\\n\\n\\n    _this6.items = [];\\n    _this6.partner = null;\\n    return _this6;\\n  }\\n\\n  return NCCNode;\\n}(ReteNode);\\n/**\\n   To store potential partial matches in the subnetwork for a NCCNode.\\n   @param parent\\n   @param num\\n   @class NCCPartnerNode\\n*/\\n\\n\\nvar NCCPartnerNode =\\n/*#__PURE__*/\\nfunction (_ReteNode6) {\\n  _inherits(NCCPartnerNode, _ReteNode6);\\n\\n  function NCCPartnerNode(parent, num) {\\n    var _this7;\\n\\n    _classCallCheck(this, NCCPartnerNode);\\n\\n    //get the parent if parent is a beta memory to stop redundant node usage\\n    _this7 = _possibleConstructorReturn(this, _getPrototypeOf(NCCPartnerNode).call(this, parent));\\n    _this7.type = "NCCPartnerNode";\\n    _this7.nccNode = null;\\n    _this7.numberOfConjuncts = num;\\n    _this7.newResultBuffer = [];\\n    return _this7;\\n  }\\n\\n  return NCCPartnerNode;\\n}(ReteNode); //--------------------\\n\\n\\n\\n\\n//# sourceURL=webpack://Rete/./ReteDataStructures.js?\');\n    },\n    "./ReteNetworkBuilding.js":\n    /*!********************************!*\\\n      !*** ./ReteNetworkBuilding.js ***!\n      \\********************************/\n\n    /*! exports provided: default */\n    function ReteNetworkBuildingJs(module, __webpack_exports__, __webpack_require__) {\n      "use strict";\n\n      eval(\'__webpack_require__.r(__webpack_exports__);\\n/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash */ "lodash");\\n/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);\\n/* harmony import */ var _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ReteDataStructures */ "./ReteDataStructures.js");\\n/* harmony import */ var _ReteUtilities__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ReteUtilities */ "./ReteUtilities.js");\\n/* harmony import */ var _ReteActivationAndDeletion__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ReteActivationAndDeletion */ "./ReteActivationAndDeletion.js");\\n/**\\n   Functions to create the actual Alpha and Beta Networks of the ReteNet\\n   @module ReteNetworkBuilding\\n   @requires ReteDataStructures\\n   @requires ReteUtilities\\n   @requires ReteActivationAndDeletion\\n   @requires lodash\\n*/\\n\\n\\n\\n\\n/**\\n   To add all given conditions to the network\\n   @param parent\\n   @param conditions\\n   @param rootAlpha\\n   @param allNodes\\n   @param reteNet\\n   @function buildOrShareNetworkForConditions\\n\\n*/\\n\\nvar buildOrShareNetworkForConditions = function buildOrShareNetworkForConditions(parent, conditions, rootAlpha, allNodes, reteNet) {\\n  var currentNode = parent,\\n      alphaMemory; //for each condition\\n\\n  conditions.forEach(function (condition) {\\n    if (condition.tags.type !== \\\'rule\\\' && condition.tags.type !== \\\'condition\\\') {\\n      throw new Error("trying to add something that isnt a condition");\\n    }\\n\\n    if (condition.tags.type === \\\'condition\\\' && condition.tags.conditionType === undefined) {\\n      throw new Error("Trying to add a condition without a conditionType");\\n    } //get the binding tests for join nodes\\n\\n\\n    var tests = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.toPairs(condition.bindings);\\n\\n    if (condition.tags.conditionType === \\\'positive\\\') {\\n      //Build a positive condition:\\n      //currentNode = buildOrShareBetaMemoryNode(currentNode,reteNet);\\n      alphaMemory = buildOrShareAlphaMemory(condition, rootAlpha, allNodes, reteNet);\\n      currentNode = buildOrShareJoinNode(currentNode, alphaMemory, tests, reteNet);\\n    } else if (condition.tags.conditionType === \\\'negative\\\') {\\n      //Build a negative condition:\\n      alphaMemory = buildOrShareAlphaMemory(condition, rootAlpha, allNodes, reteNet);\\n      currentNode = buildOrShareNegativeNode(currentNode, alphaMemory, tests, reteNet);\\n    } else if (condition.tags.conditionType === \\\'negConjCondition\\\') {\\n      //Build a Negated Conjunctive Condition\\n      currentNode = buildOrShareNCCNodes(currentNode, condition, rootAlpha, allNodes, reteNet);\\n    } else if (condition.tags.type === \\\'rule\\\') {\\n      //for using other rules as composable conditions\\n      var ruleConditions = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.toPairs(condition.linkedNodes).filter(function (d) {\\n        return /^condition/.test(d[1]);\\n      }).map(function (d) {\\n        return allNodes[d[0]];\\n      });\\n\\n      currentNode = buildOrShareNetworkForConditions(currentNode, ruleConditions, rootAlpha, allNodes, reteNet);\\n    } else {\\n      console.error("Problematic Condition:", condition);\\n      throw new Error("Unrecognised condition type");\\n    }\\n  }); //build a final memory node if current isn\\\'t one\\n\\n  return buildOrShareBetaMemoryNode(currentNode, reteNet);\\n};\\n/**\\n   Reuse, or create a new, constant test node, for the given test\\n   @param parent\\n   @param constantTestSped\\n   @param reteNet\\n   @function buildOrShareConstantTestNode\\n*/\\n\\n\\nvar buildOrShareConstantTestNode = function buildOrShareConstantTestNode(parent, constantTestSpec, reteNet) {\\n  var children = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.values(parent.children);\\n\\n  for (var i = 0; i < children.length; i++) {\\n    var node = children[i];\\n\\n    if (_ReteUtilities__WEBPACK_IMPORTED_MODULE_2__["compareConstantNodeToTest"](node, constantTestSpec)) {\\n      return node;\\n    }\\n  } //No existing, create a new node:\\n\\n\\n  var newAlphaNode = new _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["AlphaNode"](parent, constantTestSpec);\\n  reteNet.storeNode(newAlphaNode);\\n  return newAlphaNode;\\n};\\n/**\\n   Create alpha network as necessary, stick an alpha memory on the end\\n   @param condition\\n   @param root\\n   @param allNodes\\n   @param reteNet\\n   @function buildOrShareAlphaMemory\\n*/\\n\\n\\nvar buildOrShareAlphaMemory = function buildOrShareAlphaMemory(condition, root, allNodes, reteNet) {\\n  //Rule{Conditions[]}, Condition{constantTests:[],bindings:[[]]}\\n  var currentNode = root,\\n      constantTests = condition.constantTests; //[{field:,op:,value:}]\\n\\n  currentNode = constantTests.reduce(function (m, v) {\\n    return buildOrShareConstantTestNode(m, v, reteNet);\\n  }, currentNode); //see if there is an existing memory for this condition.\\n  //if so, return existing alphamemory\\n\\n  if (currentNode.outputMemory !== undefined) {\\n    return currentNode.outputMemory;\\n  } //else: create the alpha memory\\n  //ctor will update the current node\\\'s outputMemory field\\n\\n\\n  var newAlphaMemory = new _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["AlphaMemory"](currentNode); //run wmes in working memory against the alpha network\\n\\n  reteNet.storeNode(newAlphaMemory);\\n  return newAlphaMemory;\\n};\\n/**\\n   Given a node (ie: join), stick a betamemory on it as a child\\n   @param parent\\n   @param reteNet\\n   @function buildOrShareBetaMemoryNode\\n*/\\n\\n\\nvar buildOrShareBetaMemoryNode = function buildOrShareBetaMemoryNode(parent, reteNet) {\\n  //if passed in the dummy top node, OR any sort of memory node,\\n  //be it NCC,Negative,NCCPartner\\n  if (parent instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["BetaMemory"] || parent instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["NCCPartnerNode"] || parent instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["NegativeNode"] || parent instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["NCCNode"] || parent instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["JoinNode"]) {\\n    return parent;\\n  } //if theres an available beta memory to use,\\n  //return that\\n\\n\\n  var children = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.values(parent.children);\\n\\n  for (var i = 0; i < children.length; i++) {\\n    var child = children[i];\\n\\n    if (child instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["BetaMemory"]) {\\n      return child;\\n    }\\n  } //else: create a new beta memory\\n  //ctor should update  parent\\\'s children\\n\\n\\n  var newBetaMemory = new _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["BetaMemory"](parent); //update it with matches\\n\\n  updateNewNodeWithMatchesFromAbove(newBetaMemory);\\n  reteNet.storeNode(newBetaMemory); //return new beta memory\\n\\n  return newBetaMemory;\\n};\\n/**\\n   To reuse, or create a new, join node linking an alpha memory and betamemory\\n   @param parent\\n   @param alphaMemory\\n   @param tests\\n   @param reteNet\\n   @function buildOrShareJoinNode\\n*/\\n\\n\\nvar buildOrShareJoinNode = function buildOrShareJoinNode(parent, alphaMemory, tests, reteNet) {\\n  //convert tests if necessary:\\n  if (!(tests instanceof Array)) {\\n    tests = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.toPairs(tests);\\n  } //see if theres a join node to use already\\n\\n\\n  var allChildren = parent.children.concat(parent.unlinkedChildren);\\n\\n  for (var i = 0; i < allChildren.length; i++) {\\n    var child = allChildren[i];\\n\\n    if (child instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["JoinNode"] && child.alphaMemory && child.alphaMemory.id === alphaMemory.id && _ReteUtilities__WEBPACK_IMPORTED_MODULE_2__["compareJoinTests"](child.tests, tests)) {\\n      //return it\\n      return child;\\n    }\\n  } //else: create a new join node\\n  //increment alphamemories reference count in the constructor\\n\\n\\n  var newJoinNode = new _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["JoinNode"](parent, alphaMemory, tests); //set the nearest ancestor\\n\\n  newJoinNode.nearestAncestor = _ReteUtilities__WEBPACK_IMPORTED_MODULE_2__["findNearestAncestorWithAlphaMemory"](parent, alphaMemory); //if either parent memory is empty, unlink\\n\\n  if (parent.items.length === 0) {\\n    //BETA IS EMPTY: UNLINK RIGHT\\n    var index = alphaMemory.children.map(function (d) {\\n      return d.id;\\n    }).indexOf(newJoinNode.id),\\n        removed = alphaMemory.children.splice(index, 1);\\n    alphaMemory.unlinkedChildren.unshift(removed[0]);\\n  } else if (alphaMemory.items.length === 0) {\\n    //ALPHA IS EMPTY: UNLINK LEFT\\n    var newNodeIndex = parent.children.map(function (d) {\\n      return d.id;\\n    }).indexOf(newJoinNode.id),\\n        removedNode = parent.children.splice(newNodeIndex, 1);\\n    parent.unlinkedChildren.unshift(removedNode[0]);\\n  } //return new join node\\n\\n\\n  reteNet.storeNode(newJoinNode);\\n  return newJoinNode;\\n};\\n/**\\n   To reuse, or build a new, negative node\\n   @param parent\\n   @param alphaMemory\\n   @param tests\\n   @param reteNet\\n   @function buildOrShareNegativeNode\\n*/\\n\\n\\nvar buildOrShareNegativeNode = function buildOrShareNegativeNode(parent, alphaMemory, tests, reteNet) {\\n  if (!(tests instanceof Array)) {\\n    tests = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.toPairs(tests);\\n  } //see if theres an existing negative node to use\\n\\n\\n  var children = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.values(parent.children);\\n\\n  for (var i = 0; i < children.length; i++) {\\n    var child = children[i];\\n\\n    if (child instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["NegativeNode"] && child.alphaMemory && child.alphaMemory.id === alphaMemory.id && _ReteUtilities__WEBPACK_IMPORTED_MODULE_2__["compareJoinTests"](child.tests, tests)) {\\n      return child;\\n    }\\n  }\\n\\n  var newNegativeNode = new _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["NegativeNode"](parent, alphaMemory, tests);\\n  newNegativeNode.nearestAncestor = _ReteUtilities__WEBPACK_IMPORTED_MODULE_2__["findNearestAncestorWithAlphaMemory"](parent, alphaMemory); //update with matches\\n\\n  updateNewNodeWithMatchesFromAbove(newNegativeNode); //unlink if it has no tokens\\n\\n  if (newNegativeNode.items.length === 0) {\\n    var index = alphaMemory.children.map(function (d) {\\n      return d.id;\\n    }).indexOf(newNegativeNode.id),\\n        removed = alphaMemory.children.splice(index, 1);\\n    alphaMemory.unlinkedChildren.push(removed[0]);\\n  } //return new negative node\\n\\n\\n  reteNet.storeNode(newNegativeNode);\\n  return newNegativeNode;\\n};\\n/**\\n   Construction of NCCConditions\\n   @param parent\\n   @param condition\\n   @param rootAlpha\\n   @param allNodes\\n   @param reteNet\\n   @function buildOrShareNCCNodes\\n\\n*/\\n\\n\\nvar buildOrShareNCCNodes = function buildOrShareNCCNodes(parent, condition, rootAlpha, allNodes, reteNet) {\\n  if (condition.tags.conditionType !== \\\'negConjCondition\\\') {\\n    throw new Error("BuildOrShareNCCNodes only takes NCCCondition");\\n  } //build a network for the conditions\\n\\n\\n  var conditionIdPairs = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.toPairs(condition.linkedNodes).filter(function (d) {\\n    return /condition/.test(d[1]);\\n  }),\\n      conditions = conditionIdPairs.map(function (d) {\\n    return allNodes[d[0]];\\n  }),\\n      //build the subnetwork\\n  bottomOfSubNetwork = buildOrShareNetworkForConditions(parent, conditions, rootAlpha, allNodes, reteNet); //find an existing NCCNode with partner to use\\n\\n\\n  for (var i = 0; i < parent.children.length; i++) {\\n    var child = parent.children[i];\\n\\n    if (child instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["NCCNode"] && child.partner.parent && child.partner.parent.id === bottomOfSubNetwork.id) {\\n      return child;\\n    }\\n  } //else: build NCC and Partner nodes\\n\\n\\n  var newNCC = new _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["NCCNode"](parent),\\n      newNCCPartner = new _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["NCCPartnerNode"](bottomOfSubNetwork, conditionIdPairs.length);\\n  newNCC.partner = newNCCPartner;\\n  newNCCPartner.nccNode = newNCC; //update NCC\\n\\n  updateNewNodeWithMatchesFromAbove(newNCC); //update partner\\n\\n  updateNewNodeWithMatchesFromAbove(newNCCPartner);\\n  reteNet.storeNode(newNCC);\\n  reteNet.storeNode(newNCCPartner);\\n  return newNCC;\\n};\\n/**\\n   Pulls tokens down from parent upon new creation\\n   @note Possible race conditions?\\n   @param newNode\\n   @function updateNewNodeWithMatchesFromAbove\\n*/\\n\\n\\nvar updateNewNodeWithMatchesFromAbove = function updateNewNodeWithMatchesFromAbove(newNode) {\\n  //essentially a 4 state switch:\\n  //betaMemory, joinNode, negativeNode, NCC\\n  var parent = newNode.parent;\\n\\n  if (parent instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["BetaMemory"]) {\\n    for (var i = 0; i < parent.items.length; i++) {\\n      _ReteActivationAndDeletion__WEBPACK_IMPORTED_MODULE_3__["leftActivate"](newNode, parent.items[i]);\\n    }\\n  } else if (parent instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["JoinNode"]) {\\n    var savedChildren = parent.children,\\n        items = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.values(parent.alphaMemory.items);\\n\\n    parent.children = [newNode];\\n\\n    for (var _i = 0; _i < items.length; _i++) {\\n      var item = items[_i];\\n      _ReteActivationAndDeletion__WEBPACK_IMPORTED_MODULE_3__["rightActivate"](parent, item.wme);\\n    }\\n\\n    parent.children = savedChildren;\\n  } else if (parent instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["NegativeNode"]) {\\n    var _items = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.values(parent.items);\\n\\n    for (var _i2 = 0; _i2 < _items.length; _i2++) {\\n      var token = _items[_i2];\\n\\n      if (token.negJoinResults.length === 0) {\\n        _ReteActivationAndDeletion__WEBPACK_IMPORTED_MODULE_3__["leftActivate"](newNode, token);\\n      }\\n    }\\n  } else if (parent instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["NCCNode"]) {\\n    var _items2 = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.values(parent.items);\\n\\n    for (var _i3 = 0; _i3 < _items2.length; _i3++) {\\n      var _token = parent.items[_i3];\\n\\n      if (_token.nccResults.length === 0) {\\n        _ReteActivationAndDeletion__WEBPACK_IMPORTED_MODULE_3__["leftActivate"](newNode, _token);\\n      }\\n    }\\n  }\\n};\\n\\n/* harmony default export */ __webpack_exports__["default"] = (buildOrShareNetworkForConditions);\\n\\n//# sourceURL=webpack://Rete/./ReteNetworkBuilding.js?\');\n    },\n    "./ReteTestExecution.js":\n    /*!******************************!*\\\n      !*** ./ReteTestExecution.js ***!\n      \\******************************/\n\n    /*! exports provided: default */\n    function ReteTestExecutionJs(module, __webpack_exports__, __webpack_require__) {\n      "use strict";\n\n      eval(\'__webpack_require__.r(__webpack_exports__);\\n/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash */ "lodash");\\n/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);\\n/* harmony import */ var _ReteUtilities__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ReteUtilities */ "./ReteUtilities.js");\\n/* harmony import */ var _ReteComparisonOperators__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ReteComparisonOperators */ "./ReteComparisonOperators.js");\\n/**\\n   @module ReteTestExecution\\n   @requires ReteDataStructures\\n   @requires lodash\\n   @requires ReteUtilities\\n   @requires ReteComparisonOperators\\n*/\\n\\n\\n\\n/**\\n   Compare a token and wme, using defined bindings from a joinNode\\n   @param joinNode\\n   @param token\\n   @param wme\\n   @function performJoinTests\\n   @returns {False | Object}\\n*/\\n\\nvar performJoinTests = function performJoinTests(joinNode, token, wme) {\\n  //returns False if no match, dict of all updated bindings otherwise\\n  var newBindings = {},\\n      successState = true,\\n      varRegex = new RegExp(/^\\\\${(\\\\w+)}/); //Populate with current bindings from token\\n\\n  lodash__WEBPACK_IMPORTED_MODULE_0___default.a.keys(token.bindings).forEach(function (key) {\\n    newBindings[key] = token.bindings[key];\\n  });\\n\\n  try {\\n    //add new bindings:\\n    joinNode.tests.forEach(function (test) {\\n      var newValue = null; //retrieve the value\\n\\n      if (/^[#$]id$/.test(test[1][0])) {\\n        newValue = wme.id;\\n      } else {\\n        newValue = _ReteUtilities__WEBPACK_IMPORTED_MODULE_1__["retrieveWMEValueFromDotString"](wme, test[1][0]);\\n      } //compare the value for each specified binding test\\n\\n\\n      var bindingComparisons = test[1][1]; //Compare using any defined binding tests\\n\\n      bindingComparisons.forEach(function (d) {\\n        var comparator = _ReteComparisonOperators__WEBPACK_IMPORTED_MODULE_2__["default"][d[0]],\\n            varName = d[1],\\n            match = varRegex.exec(varName); //if it fails, fail the test\\n        //use the value in the test, minus the $ at the beginning:\\n\\n        if (match === null) {\\n          throw new Error("No bound let name");\\n        } //if (!varRegex.test(varName)) { throw new Error("Non-bound let name"); }\\n\\n\\n        if (!comparator(newValue, newBindings[match[1]])) {\\n          throw new Error("Test failed");\\n        }\\n      });\\n\\n      if (newBindings[test[0]] === undefined) {\\n        newBindings[test[0]] = newValue;\\n      }\\n\\n      if (newBindings[test[0]] !== newValue) {\\n        throw new Error("Test failed");\\n      }\\n    });\\n\\n    if (successState) {\\n      return newBindings;\\n    }\\n\\n    throw new Error("Test failed");\\n  } catch (e) {\\n    return false;\\n  }\\n};\\n\\n/* harmony default export */ __webpack_exports__["default"] = (performJoinTests);\\n\\n//# sourceURL=webpack://Rete/./ReteTestExecution.js?\');\n    },\n    "./ReteUtilities.js":\n    /*!**************************!*\\\n      !*** ./ReteUtilities.js ***!\n      \\**************************/\n\n    /*! exports provided: unlinkAlphaMemory, relinkToAlphaMemory, ifEmptyBetaMemoryUnlink, ifEmptyNegNodeUnlink, relinkToBetaMemory, compareJoinTests, compareConstantNodeToTest, findNearestAncestorWithAlphaMemory, retrieveWMEValueFromDotString, cleanupInvalidatedActions, objDescToObject, createNewWMEData, applyArithmetic, applyRegex */\n    function ReteUtilitiesJs(module, __webpack_exports__, __webpack_require__) {\n      "use strict";\n\n      eval(\'__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unlinkAlphaMemory", function() { return unlinkAlphaMemory; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "relinkToAlphaMemory", function() { return relinkToAlphaMemory; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ifEmptyBetaMemoryUnlink", function() { return ifEmptyBetaMemoryUnlink; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ifEmptyNegNodeUnlink", function() { return ifEmptyNegNodeUnlink; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "relinkToBetaMemory", function() { return relinkToBetaMemory; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "compareJoinTests", function() { return compareJoinTests; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "compareConstantNodeToTest", function() { return compareConstantNodeToTest; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findNearestAncestorWithAlphaMemory", function() { return findNearestAncestorWithAlphaMemory; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "retrieveWMEValueFromDotString", function() { return retrieveWMEValueFromDotString; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cleanupInvalidatedActions", function() { return cleanupInvalidatedActions; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "objDescToObject", function() { return objDescToObject; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createNewWMEData", function() { return createNewWMEData; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "applyArithmetic", function() { return applyArithmetic; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "applyRegex", function() { return applyRegex; });\\n/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash */ "lodash");\\n/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);\\n/* harmony import */ var _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ReteDataStructures */ "./ReteDataStructures.js");\\n/* harmony import */ var _ReteArithmeticActions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ReteArithmeticActions */ "./ReteArithmeticActions.js");\\nfunction _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\\n\\n/**\\n   @module ReteUtilities\\n   @requires lodash\\n*/\\n\\n\\n\\n/**\\n   Reconnects a joinnode with its alpha memory, once the beta memory is populated\\n   @param node\\n   @function relinkToAlphaMemory\\n*/\\n\\nvar relinkToAlphaMemory = function relinkToAlphaMemory(node) {\\n  //reconnect an unlinked join node to its alpha memory when there are\\n  //wmes in said alpha memory\\n  if (!(node instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["JoinNode"] || node instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["NegativeNode"])) {\\n    throw new Error("trying to relink alpha on something other than a join node or negative node");\\n  }\\n\\n  var ancestor = node.nearestAncestor,\\n      indices = node.alphaMemory.children.map(function (d) {\\n    return d.id;\\n  }); //While the ancestor is a child of the alpha memory\\n\\n  while (ancestor && indices.indexOf(ancestor.id) === -1) {\\n    //go up an ancestor if it is unlinked to\\n    ancestor = findNearestAncestorWithAlphaMemory(ancestor, node.alphaMemory.id);\\n  } //When finished, if the ancestor exists:\\n\\n\\n  if (ancestor !== null) {\\n    var index = node.alphaMemory.children.map(function (d) {\\n      return d.id;\\n    }).indexOf(ancestor.id); //add the node into the child list in front of the ancestor\\n\\n    node.alphaMemory.children.splice(index, 0, node);\\n  } else {\\n    //otherwise just add at the end\\n    node.alphaMemory.children.push(node);\\n  } //remove from the unlinkedChildren Field\\n\\n\\n  var nodeIndex = node.alphaMemory.unlinkedChildren.map(function (d) {\\n    return d.id;\\n  }).indexOf(node.id);\\n  node.alphaMemory.unlinkedChildren.splice(nodeIndex, 1);\\n};\\n/**\\n   Reconnects a join node to its beta memory, once the alpha memory is populated\\n   @param node\\n   @function relinkToBetaMemory\\n*/\\n\\n\\nvar relinkToBetaMemory = function relinkToBetaMemory(node) {\\n  //relink an unlinked join node to its betamemory when there are tokens\\n  //in said memory\\n  //remove from the unlinked children list\\n  //and add it into the children\\n  if (node.parent.unlinkedChildren.length === 0) {\\n    return;\\n  }\\n\\n  var index = node.parent.unlinkedChildren.map(function (d) {\\n    return d.id;\\n  }).indexOf(node.id);\\n\\n  if (index > -1) {\\n    node.parent.unlinkedChildren.splice(index, 1);\\n    node.parent.children.unshift(node);\\n  }\\n};\\n/**\\n   If an alpha memory becomes empty, displace all its children temporarily\\n   @param alphaMemory\\n   @function unlinkAlphaMemory\\n*/\\n\\n\\nvar unlinkAlphaMemory = function unlinkAlphaMemory(alphaMemory) {\\n  //if the alphaMem has no items: UNLINK\\n  if (alphaMemory.items.length === 0) {\\n    alphaMemory.children.forEach(function (amChild) {\\n      if (amChild instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["JoinNode"]) {\\n        var index = amChild.parent.children.map(function (d) {\\n          return d.id;\\n        }).indexOf(amChild.id); //splice out\\n\\n        var removed = amChild.parent.children.splice(index, 1); //and store\\n\\n        amChild.parent.unlinkedChildren.push(removed[0]);\\n      }\\n    });\\n  }\\n};\\n/**\\n   If a beta memory becomes empty, displace all its children temporarily\\n   @param node\\n   @function ifEmptyBetaMemoryUnlink\\n*/\\n\\n\\nvar ifEmptyBetaMemoryUnlink = function ifEmptyBetaMemoryUnlink(node) {\\n  //Now Essentially switch on: BetaMemory, NegativeNode,\\n  //NCCNode, and NCCPartnerNode\\n  //BETAMEMORY\\n  if (node && (node instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["BetaMemory"] || node instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["JoinNode"])) {\\n    //and that betaMemory has no other items\\n    if (node.items.length === 0) {\\n      //for all the node\\\'s children\\n      node.children.forEach(function (jn) {\\n        if (!(jn instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["JoinNode"])) {\\n          return;\\n        }\\n\\n        var index = jn.alphaMemory.children.map(function (d) {\\n          return d.id;\\n        }).indexOf(jn.id);\\n\\n        if (index !== -1) {\\n          var removed = jn.alphaMemory.children.splice(index, 1); //push it in the unlinked children list\\n\\n          jn.alphaMemory.unlinkedChildren.push(removed[0]);\\n        }\\n      });\\n    }\\n\\n    return true;\\n  }\\n\\n  return false;\\n};\\n/**\\n   If a negative node becomes empty, displace its alpha memory\\\'s children\\n   @param node\\n   @function ifEmptyNegNodeUnlink\\n*/\\n\\n\\nvar ifEmptyNegNodeUnlink = function ifEmptyNegNodeUnlink(node) {\\n  if (node && node instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["NegativeNode"]) {\\n    //with elements\\n    if (node.items.length === 0) {\\n      //unlink alpha memory\\n      var index = node.alphaMemory.children.map(function (d) {\\n        return d.id;\\n      }).indexOf(node.id);\\n      var removed = node.alphaMemory.children.splice(index, 1);\\n      node.alphaMemory.unlinkedChildren.push(removed[0]);\\n    }\\n  }\\n};\\n/**\\n   Compare an existing constant test node to a constant test that wants to be built\\n   @param node\\n   @param constantTestSpec\\n   @function compareConstantNodeToTest\\n*/\\n//taking an alpha node and a ConstantTest\\n\\n\\nvar compareConstantNodeToTest = function compareConstantNodeToTest(node, constantTestSpec) {\\n  if (node.testField !== constantTestSpec.field || node.testValue !== constantTestSpec.value) {\\n    return false;\\n  }\\n\\n  if (node.operator !== constantTestSpec.operator) {\\n    return false;\\n  }\\n\\n  return true;\\n};\\n/**\\n   Compare specified join tests, to see if a join node is the same as one needed\\n   @param firstTestSet\\n   @param secondTestSet\\n   @function compareJoinTests\\n*/\\n\\n\\nvar compareJoinTests = function compareJoinTests(firstTestSet, secondTestSet) {\\n  try {\\n    //compare lengths\\n    if (firstTestSet.length !== secondTestSet.length) {\\n      throw "unequal lengths";\\n    }\\n\\n    for (var i = 0; i < firstTestSet.length; i++) {\\n      var fTest = firstTestSet[i],\\n          sTest = secondTestSet[i]; //compare the bound names\\n\\n      if (fTest[0] !== sTest[0]) {\\n        throw "different bound names";\\n      } //compare the source names\\n\\n\\n      if (fTest[1][0] !== sTest[1][0]) {\\n        throw "different source names";\\n      } //compare the bind tests\\n\\n\\n      if (fTest[1][1].length !== sTest[1][1].length) {\\n        throw "different binding tests length";\\n      }\\n\\n      for (var j = 0; fTest[1][1].length; j++) {\\n        if (fTest[1][1][j][0] !== sTest[1][1][j][0]) {\\n          throw "different comp operator";\\n        }\\n\\n        if (fTest[1][1][j][1] !== sTest[1][1][j][1]) {\\n          throw "different comp value";\\n        }\\n      }\\n    }\\n  } catch (e) {\\n    return false;\\n  }\\n\\n  return true;\\n};\\n/**\\n   To go up the network, to find appropriate beta network elements linked to the alphamemory\\n   @param node\\n   @param alphaMemory\\n   @function findNearestAncestorWithAlphaMemory\\n*/\\n\\n\\nvar findNearestAncestorWithAlphaMemory = function findNearestAncestorWithAlphaMemory(node, alphaMemory) {\\n  //recursive\\n  //base conditions:\\n  if (node.dummy) {\\n    return null;\\n  }\\n\\n  if (node instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["JoinNode"] || node instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["NegativeNode"]) {\\n    if (node.alphaMemory.id === alphaMemory.id) {\\n      return node;\\n    }\\n  } //switch recursion into the partner clause\\n\\n\\n  if (node instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["NCCNode"]) {\\n    return findNearestAncestorWithAlphaMemory(node.partner.parent, alphaMemory);\\n  } //recurse:\\n\\n\\n  return findNearestAncestorWithAlphaMemory(node.parent, alphaMemory);\\n}; //--------------------\\n\\n/**\\n   Retrieves a value from an object based on a dot style strings\\n   eg: "values.object.a" will get { values : { object { a : 5 } } }\\n   @param wme\\n   @param dotString\\n   @function\\n */\\n\\n\\nvar retrieveWMEValueFromDotString = function retrieveWMEValueFromDotString(wme, dotString) {\\n  //get from the node stored in wme.data the value\\n  //that the dotString address specifies\\n  var address = dotString.split("."),\\n      currLocation = wme.data;\\n\\n  while (address.length > 0) {\\n    var curr = address.shift();\\n\\n    if (currLocation[curr] !== undefined) {\\n      currLocation = currLocation[curr];\\n    } else {\\n      return null;\\n    }\\n  } //return the final location arrived at\\n\\n\\n  return currLocation;\\n};\\n/**\\n   Remove proposed actions from the retenet, and from their owning tokens\\n   @param invalidatedActions\\n   @function\\n*/\\n\\n\\nvar cleanupInvalidatedActions = function cleanupInvalidatedActions(invalidatedActions) {\\n  if (invalidatedActions.length === 0 || invalidatedActions[0].reteNet === undefined) {\\n    return;\\n  }\\n\\n  var reteNet = invalidatedActions[0].reteNet,\\n      idList = invalidatedActions.map(function (d) {\\n    return d.id;\\n  }); //filter out the ids from the proposedActions list\\n  //also removing them from the owning tokens\\n\\n  lodash__WEBPACK_IMPORTED_MODULE_0___default.a.forEach(idList, function (d) {\\n    return reteNet.unproposeAction(d);\\n  });\\n};\\n/**\\n   Take a single object that describes a more complex object, and convert it to that more complex object\\n   @param objDesc\\n   @param baseObject\\n   @function objDescToObject\\n*/\\n\\n\\nvar objDescToObject = function objDescToObject(objDesc, baseObject) {\\n  /* can work on arbitrary depths, will overwrite primitives if later an object is needed\\n     \\n     ie: {"values.a" : 5, "values.b" : 10,\\n     "tags.type" : "rule", "tags.character" : "bob"}\\n     ---\\x3e\\n     {"values": {"a": 5, "b": 10},\\n     "tags" : {"type" : "rule", "character": "bob"}}\\n  */\\n  var newObj = baseObject || {},\\n      //take the starting object and for all keys\\n  finalObj = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.keys(objDesc).reduce(function (m, v) {\\n    //split the keys apart\\n    var keys = v.split(/\\\\./),\\n        currObj = m,\\n        currKey; //add an object for each key\\n\\n    while (keys.length > 1) {\\n      currKey = keys.shift();\\n\\n      if (currObj[currKey] === undefined || _typeof(currObj[currKey]) !== \\\'object\\\') {\\n        currObj[currKey] = {};\\n      }\\n\\n      currObj = currObj[currKey];\\n    }\\n\\n    currKey = keys.shift();\\n    currObj[currKey] = objDesc[v];\\n    return m;\\n  }, newObj);\\n\\n  return finalObj;\\n};\\n/**\\n   Create new wme data from an action description and a token\\\'s bindings\\n   @param {Action} action\\n   @param {Token} token\\n */\\n\\n\\nvar createNewWMEData = function createNewWMEData(action, token) {\\n  //initialise from the action\\\'s \\\'values\\\' object\\n  var newWMEData = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.reduce(lodash__WEBPACK_IMPORTED_MODULE_0___default.a.keys(action.values), function (memo, key) {\\n    var v = action.values[key]; //splice in bindings into the values\\n\\n    memo[key] = spliceInValues(v, token.bindings);\\n    return memo;\\n  }, {\\n    bindings: {}\\n  }),\\n      //copy in the bindings\\n  dataPlusBindings = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.reduce(lodash__WEBPACK_IMPORTED_MODULE_0___default.a.keys(token.bindings), function (m, v) {\\n    m.bindings[v] = token.bindings[v];\\n    return m;\\n  }, newWMEData);\\n\\n  return dataPlusBindings;\\n};\\n/**\\n   Apply arithmetic actions to a data object, in place\\n   @param {Action} action\\n   @param {Object} data\\n */\\n\\n\\nvar applyArithmetic = function applyArithmetic(action, data) {\\n  //perform arithmetic:\\n  lodash__WEBPACK_IMPORTED_MODULE_0___default.a.keys(action.arithmeticActions).forEach(function (key) {\\n    var arithDesc = action.arithmeticActions[key],\\n        currVal = Number(data[key]),\\n        //look up the function:\\n    //because the representation form is: a : ["+", 5]\\n    arithFunc = _ReteArithmeticActions__WEBPACK_IMPORTED_MODULE_2__["default"][arithDesc[0]],\\n        //Get the value if its a binding\\n    applyVal = typeof arithDesc[1] === \\\'number\\\' ? arithDesc[1] : arithDesc[1].match(/\\\\$/) ? parseInt(data.bindings[arithDesc[1].slice(1)], 10) : parseInt(arithDesc[1], 10);\\n\\n    if (arithFunc === undefined) {\\n      throw new Error("Undefined arithmetic function");\\n    }\\n\\n    if (isNaN(currVal) || isNaN(applyVal)) {\\n      throw new Error("Arithmetic value should be convertable to a number: " + currVal + " " + applyVal);\\n    }\\n\\n    data[key] = arithFunc(currVal, applyVal);\\n  });\\n};\\n/**\\n   Apply an actions Regex transforms to some data, in place\\n   @param {Action} action\\n   @param {Object} data\\n */\\n\\n\\nvar applyRegex = function applyRegex(action, data) {\\n  lodash__WEBPACK_IMPORTED_MODULE_0___default.a.keys(action.regexActions).forEach(function (key) {\\n    var regexAction = action.regexActions[key],\\n        regex = new RegExp(regexAction[0], regexAction[1]),\\n        replaceValue = spliceInValues(regexAction[2], data.bindings);\\n    data[key] = data[key].replace(regex, replaceValue);\\n  });\\n};\\n/**\\n   Repeatedly splice in values into a string\\n   @param {String} baseString\\n   @param {Object} valueObject\\n */\\n\\n\\nvar spliceInValues = function spliceInValues(baseString, valueObject) {\\n  var match = /\\\\${(\\\\w+)}/g.exec(baseString);\\n\\n  while (match !== null) {\\n    if (valueObject[match[1]] !== undefined) {\\n      baseString = spliceStr(baseString, match.index, valueObject[match[1]], match[0].length);\\n    } else {\\n      throw new Error("Unrecognised binding: " + match[1]);\\n    }\\n\\n    match = /\\\\${(\\\\w+)}/g.exec(baseString);\\n  }\\n\\n  return baseString;\\n};\\n/**\\n   Utility function to splice a string, from\\n   http://stackoverflow.com/questions/20817618/is-there-a-splice-method-for-strings\\n   @param {String} orig the original string\\n   @param {Int} index the start point to splice from\\n   @param {String} addition The string to splce in\\n   @param {Int} cutLength The amount after the index to ignore before using the remaining string\\n */\\n\\n\\nvar spliceStr = function spliceStr(orig, index, addition, cutLength) {\\n  return orig.slice(0, index) + addition + orig.slice(index + cutLength);\\n}; //------------------------------\\n\\n\\n\\n\\n//# sourceURL=webpack://Rete/./ReteUtilities.js?\');\n    },\n    "./RuleCtors.js":\n    /*!**********************!*\\\n      !*** ./RuleCtors.js ***!\n      \\**********************/\n\n    /*! exports provided: Rule, Condition, Action */\n    function RuleCtorsJs(module, __webpack_exports__, __webpack_require__) {\n      "use strict";\n\n      eval(\'__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Rule", function() { return Rule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Condition", function() { return Condition; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Action", function() { return Action; });\\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\\n\\nfunction _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }\\n\\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }\\n\\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\\n\\n/**\\n   Constructors for in-library creation of rules\\n   @module RuleCtors\\n*/\\nvar nextId = 0;\\n/**\\n   Rule Ctor. Holds conditions and actions\\n   @class\\n*/\\n\\nvar Rule = function Rule(name) {\\n  _classCallCheck(this, Rule);\\n\\n  this.id = nextId++;\\n  this.name = name || "anon";\\n  this.tags = {\\n    type: "rule"\\n  };\\n  this.conditions = {};\\n  this.actions = {};\\n};\\n/**\\n   Creates a condition and adds it to the rule\\n   @param type\\n   @param testsAndBindings\\n   @method\\n   @returns this\\n*/\\n\\n\\nRule.prototype.newCondition = function (type, testsAndBindings) {\\n  //testsAndBindings = { tests : [ [var,op,val]...], bindings : [ [var,val,[op,var]]] }\\n  var newCondition = new Condition(type); //Add all tests\\n\\n  if (testsAndBindings.tests !== undefined) {\\n    testsAndBindings.tests.forEach(function (d) {\\n      return newCondition.addTest.apply(newCondition, _toConsumableArray(d));\\n    });\\n  }\\n\\n  if (testsAndBindings.bindings !== undefined) {\\n    testsAndBindings.bindings.forEach(function (d) {\\n      return newCondition.addBinding.apply(newCondition, _toConsumableArray(d));\\n    });\\n  }\\n\\n  this.addCondition(newCondition);\\n  return this;\\n};\\n/**\\n   Creates and adds an action to the rule\\n   @param type\\n   @param name\\n   @param valuesArithRegexsAndTiming\\n   @method\\n   @returns this\\n*/\\n\\n\\nRule.prototype.newAction = function (type, name, valuesArithRegexsAndTiming) {\\n  //valuesArithRegexsAndTiming = { values : [], arith : [], regexs : [], timing : [], priority : n}\\n  var newAction = new Action(type, name);\\n\\n  if (valuesArithRegexsAndTiming.values !== undefined) {\\n    valuesArithRegexsAndTiming.values.forEach(function (d) {\\n      return newAction.addValue.apply(newAction, _toConsumableArray(d));\\n    });\\n  }\\n\\n  if (valuesArithRegexsAndTiming.arith !== undefined) {\\n    valuesArithRegexsAndTiming.arith.forEach(function (d) {\\n      return newAction.addArithmetic.apply(newAction, _toConsumableArray(d));\\n    });\\n  }\\n\\n  if (valuesArithRegexsAndTiming.regexs !== undefined) {\\n    valuesArithRegexsAndTiming.regexs.forEach(function (d) {\\n      return newAction.addRegex.apply(newAction, _toConsumableArray(d));\\n    });\\n  }\\n\\n  if (valuesArithRegexsAndTiming.priority !== undefined) {\\n    newAction.priority = valuesArithRegexsAndTiming.priority;\\n  }\\n\\n  if (valuesArithRegexsAndTiming.timing !== undefined) {\\n    newAction.addTiming.apply(newAction, _toConsumableArray(valuesArithRegexsAndTiming.timing));\\n  }\\n\\n  this.addAction(newAction);\\n  return this;\\n};\\n\\nRule.prototype.addCondition = function (condition) {\\n  this.conditions[condition.id] = condition;\\n  return this;\\n};\\n\\nRule.prototype.addAction = function (action) {\\n  this.actions[action.id] = action;\\n  return this;\\n};\\n/**\\n   Condition Ctor. Holds tests, bindings, and other conditions\\n   @param type\\n   @class\\n*/\\n\\n\\nvar Condition = function Condition(type) {\\n  _classCallCheck(this, Condition);\\n\\n  this.id = nextId++;\\n  this.name = "conditon";\\n  type = type === undefined ? "positive" : type;\\n\\n  switch (type) {\\n    case "positive":\\n      this.tags = {\\n        type: "condition",\\n        conditionType: \\\'positive\\\'\\n      };\\n      break;\\n\\n    case "negative":\\n      this.tags = {\\n        type: "condition",\\n        conditionType: \\\'negative\\\'\\n      };\\n      break;\\n\\n    case "ncc":\\n      this.tags = {\\n        type: \\\'condition\\\',\\n        conditionType: "negConjCondition"\\n      };\\n      break;\\n\\n    default:\\n      throw new Error("Unrecognised condition");\\n  }\\n\\n  this.constantTests = [];\\n  this.bindings = {};\\n  this.conditions = {};\\n};\\n/**\\n   Adds a test to the condition\\n   @param field\\n   @param op\\n   @param val\\n   @method\\n*/\\n\\n\\nCondition.prototype.addTest = function (field, op, val) {\\n  this.constantTests.push({\\n    field: field,\\n    operator: op,\\n    value: val\\n  });\\n  return this;\\n};\\n/**\\n   Adds a binding to the condition\\n   @param boundName\\n   @param dataName\\n   @param tests\\n   @method\\n*/\\n\\n\\nCondition.prototype.addBinding = function (boundName, dataName, tests) {\\n  //tests as pairs of op and value/boundName\\n  this.bindings[boundName] = [dataName, tests];\\n};\\n/**\\n   Adds a new subcondiiton to the condition\\n   @param type\\n   @param testsAndBindings\\n   @method\\n*/\\n\\n\\nCondition.prototype.newCondition = function (type, testsAndBindings) {\\n  if (this.type !== \\\'negConjCondition\\\') {\\n    throw new Error("Only NCC\\\'s can have sub conditions");\\n  }\\n\\n  var newCondition = new Condition(type);\\n  testsAndBindings.tests.forEach(function (d) {\\n    return newCondition.addTest.apply(newCondition, _toConsumableArray(d));\\n  });\\n  testsAndBindings.bindings.forEach(function (d) {\\n    return newCondition.addBinding.apply(newCondition, _toConsumableArray(d));\\n  });\\n  this.conditions[newCondition.id] = newCondition;\\n};\\n/**\\n   Action constructor, defines data/values to put in a new wme,\\n   arithmetic and regex actions to apply to those values\\n   @param actionType\\n   @param name\\n   @class\\n*/\\n\\n\\nvar Action = function Action(actionType, name) {\\n  _classCallCheck(this, Action);\\n\\n  this.id = nextId++;\\n  this.name = name || "anon";\\n  this.tags = {\\n    actionType: actionType || "assert"\\n  };\\n  this.values = {};\\n  this.arithmeticActions = {};\\n  this.regexActions = {}; //Specify the timing of the proposed action to create:\\n\\n  this.timing = {\\n    invalidateOffset: 0,\\n    performOffset: 0,\\n    unperformOffset: 0\\n  };\\n  this.priority = 0;\\n};\\n/**\\n   Add a value to the action\\n   @param varName\\n   @param value\\n   @method\\n*/\\n\\n\\nAction.prototype.addValue = function (varName, value) {\\n  this.values[varName] = value;\\n  return this;\\n};\\n/**\\n   Add an arithmetic modification to the action\\n   @param varName\\n   @param op\\n   @param value\\n   @method\\n*/\\n\\n\\nAction.prototype.addArithmetic = function (varName, op, value) {\\n  this.arithmeticActions[varName] = [op, value];\\n  return this;\\n};\\n/**\\n   Add a regular expression modification to the action\\n   @param varName\\n   @param regex\\n   @param options\\n   @param replaceValue\\n   @method\\n*/\\n\\n\\nAction.prototype.addRegex = function (varName, regex, options, replaceValue) {\\n  this.regexActions[varName] = [regex, options, replaceValue];\\n  return this;\\n};\\n/**\\n   Add timing information to the action\\n   @param invalid\\n   @param perform\\n   @param unperform\\n   @method\\n*/\\n\\n\\nAction.prototype.addTiming = function (invalid, perform, unperform) {\\n  this.timing = {\\n    invalidateOffset: invalid,\\n    performOffset: perform,\\n    unperformOffset: unperform\\n  };\\n  return this;\\n};\\n\\n\\n\\n//# sourceURL=webpack://Rete/./RuleCtors.js?\');\n    },\n    lodash:\n    /*!*************************************************************************************!*\\\n      !*** external {"commonjs":"lodash","commonjs2":"lodash","amd":"lodash","root":"_"} ***!\n      \\*************************************************************************************/\n\n    /*! no static exports found */\n    function lodash(module, exports) {\n      eval("module.exports = __WEBPACK_EXTERNAL_MODULE_lodash__;\\n\\n//# sourceURL=webpack://Rete/external_%7B%22commonjs%22:%22lodash%22,%22commonjs2%22:%22lodash%22,%22amd%22:%22lodash%22,%22root%22:%22_%22%7D?");\n    }\n  });\n});\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/module.js */ "../node_modules/webpack/buildin/module.js")(module)))\n\n//# sourceURL=webpack://JGShell/../libs/rete.js?')},"../node_modules/parsimmon/build/parsimmon.browser.min.js":
/*!****************************************************************!*\
  !*** ../node_modules/parsimmon/build/parsimmon.browser.min.js ***!
  \****************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(n,t){if(true){!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (t),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))}else {}})(this,function(){"use strict";function n(t){if(!(this instanceof n)){return new n(t)}this._=t}function t(t){return t instanceof n}var r=n.prototype;function e(n,t){return{status:true,index:n,value:t,furthest:-1,expected:[]}}function u(n,t){return{status:false,index:-1,value:null,furthest:n,expected:[t]}}function a(n,t){if(!t){return n}if(n.furthest>t.furthest){return n}var r=n.furthest===t.furthest?i(n.expected,t.expected):t.expected;return{status:n.status,index:n.index,value:n.value,furthest:t.furthest,expected:r}}function i(n,t){var r=n.length;var e=t.length;if(r===0){return t}else if(e===0){return n}var u={};for(var a=0;a<r;a++){u[n[a]]=true}for(var i=0;i<e;i++){u[t[i]]=true}var o=[];for(var f in u){if(u.hasOwnProperty(f)){o.push(f)}}o.sort();return o}function o(n){if(!t(n)){throw new Error("not a parser: "+n)}}function f(n){if(typeof n!=="number"){throw new Error("not a number: "+n)}}function s(n){if(!(n instanceof RegExp)){throw new Error("not a regexp: "+n)}var t=_(n);for(var r=0;r<t.length;r++){var e=t.charAt(r);if(e!="i"&&e!="m"&&e!="u"){throw new Error(\'unsupported regexp flag "\'+e+\'": \'+n)}}}function c(n){if(typeof n!=="function"){throw new Error("not a function: "+n)}}function l(n){if(typeof n!=="string"){throw new Error("not a string: "+n)}}function h(n){if(n.length===1){return n[0]}return"one of "+n.join(", ")}function v(n,t){var r=t.index;var e=r.offset;if(e===n.length){return", got the end of the input"}var u=e>0?"\'...":"\'";var a=n.length-e>12?"...\'":"\'";return" at line "+r.line+" column "+r.column+", got "+u+n.slice(e,e+12)+a}function p(n,t){return"expected "+h(t.expected)+v(n,t)}r.parse=function(n){if(typeof n!=="string"){throw new Error(".parse must be called with a string as its argument")}var t=this.skip(M)._(n,0);return t.status?{status:true,value:t.value}:{status:false,index:I(n,t.furthest),expected:t.expected}};r.tryParse=function(n){var t=this.parse(n);if(t.status){return t.value}else{var r=p(n,t);var e=new Error(r);e.type="ParsimmonError";e.result=t;throw e}};function d(){var t=[].slice.call(arguments);var r=t.length;for(var u=0;u<r;u+=1){o(t[u])}return n(function(n,u){var i;var o=new Array(r);for(var f=0;f<r;f+=1){i=a(t[f]._(n,u),i);if(!i.status){return i}o[f]=i.value;u=i.index}return a(e(u,o),i)})}function g(){var n=[].slice.call(arguments);if(n.length===0){throw new Error("seqMap needs at least one argument")}var t=n.pop();c(t);return d.apply(null,n).map(function(n){return t.apply(null,n)})}function m(t){return n(t(e,u))}function x(){var t=[].slice.call(arguments);var r=t.length;if(r===0){return P("zero alternates")}for(var e=0;e<r;e+=1){o(t[e])}return n(function(n,r){var e;for(var u=0;u<t.length;u+=1){e=a(t[u]._(n,r),e);if(e.status)return e}return e})}function y(n,t){return w(n,t).or(b([]))}function w(n,t){o(n);o(t);var r=t.then(n).many();return n.chain(function(n){return r.map(function(t){return[n].concat(t)})})}r.or=function(n){return x(this,n)};r.then=function(n){if(typeof n==="function"){throw new Error("chaining features of .then are no longer supported, use .chain instead")}o(n);return d(this,n).map(function(n){return n[1]})};r.many=function(){var t=this;return n(function(n,r){var u=[];var i=undefined;for(;;){i=a(t._(n,r),i);if(i.status){r=i.index;u.push(i.value)}else{return a(e(r,u),i)}}})};r.times=function(t,r){var u=this;if(arguments.length<2){r=t}f(t);f(r);return n(function(n,i){var o=[];var f=undefined;var s=undefined;for(var c=0;c<t;c+=1){f=u._(n,i);s=a(f,s);if(f.status){i=f.index;o.push(f.value)}else{return s}}for(;c<r;c+=1){f=u._(n,i);s=a(f,s);if(f.status){i=f.index;o.push(f.value)}else{break}}return a(e(i,o),s)})};r.result=function(n){return this.map(function(){return n})};r.atMost=function(n){return this.times(0,n)};r.atLeast=function(n){return g(this.times(n),this.many(),function(n,t){return n.concat(t)})};r.map=function(t){c(t);var r=this;return n(function(n,u){var i=r._(n,u);if(!i.status){return i}return a(e(i.index,t(i.value)),i)})};r["fantasy-land/map"]=r.map;r.skip=function(n){return d(this,n).map(function(n){return n[0]})};r.mark=function(){return g(L,this,L,function(n,t,r){return{start:n,value:t,end:r}})};r.lookahead=function(n){return this.skip(A(n))};r.desc=function(t){var r=this;return n(function(n,e){var u=r._(n,e);if(!u.status){u.expected=[t]}return u})};r.fallback=function(n){return this.or(b(n))};function E(t){l(t);var r="\'"+t+"\'";return n(function(n,a){var i=a+t.length;var o=n.slice(a,i);if(o===t){return e(i,o)}else{return u(a,r)}})}function _(n){var t=""+n;return t.slice(t.lastIndexOf("/")+1)}function k(n){return RegExp("^(?:"+n.source+")",_(n))}function O(t,r){s(t);if(arguments.length>=2){f(r)}else{r=0}var a=k(t);var i=""+t;return n(function(n,t){var o=a.exec(n.slice(t));if(o){var f=o[0];var s=o[r];if(s!=null){return e(t+f.length,s)}}return u(t,i)})}function b(t){return n(function(n,r){return e(r,t)})}function P(t){return n(function(n,r){return u(r,t)})}function A(r){if(t(r)){return n(function(n,t){var e=r._(n,t);e.index=t;e.value="";return e})}else if(typeof r==="string"){return A(E(r))}else if(r instanceof RegExp){return A(O(r))}throw new Error("not a string, regexp, or parser: "+r)}var z=n(function(n,t){if(t>=n.length){return u(t,"any character")}return e(t+1,n.charAt(t))});var q=n(function(n,t){return e(n.length,n.slice(t))});var M=n(function(n,t){if(t<n.length){return u(t,"EOF")}return e(t,null)});function R(t){c(t);return n(function(n,r){var a=n.charAt(r);if(r<n.length&&t(a)){return e(r+1,a)}else{return u(r,"a character matching "+t)}})}function j(n){return R(function(t){return n.indexOf(t)>=0})}function B(n){return R(function(t){return n.indexOf(t)<0})}function F(t){c(t);return n(function(n,r){var u=r;while(u<n.length&&t(n.charAt(u))){u++}return e(u,n.slice(r,u))})}function W(t,r){if(arguments.length<2){r=t;t=undefined}var e=n(function(n,t){e._=r()._;return e._(n,t)});if(t){return e.desc(t)}else{return e}}function I(n,t){var r=n.slice(0,t).split("\\n");var e=r.length;var u=r[r.length-1].length+1;return{offset:t,line:e,column:u}}var L=n(function(n,t){return e(t,I(n,t))});function S(){return P("fantasy-land/empty")}r.concat=r.or;r["fantasy-land/concat"]=r.concat;r.empty=S;r["fantasy-land/empty"]=r.empty;r.of=b;r["fantasy-land/of"]=r.of;r.ap=function(n){return g(n,this,function(n,t){return n(t)})};r["fantasy-land/ap"]=r.ap;r.chain=function(t){var r=this;return n(function(n,e){var u=r._(n,e);if(!u.status){return u}var i=t(u.value);return a(i._(n,u.index),u)})};r["fantasy-land/chain"]=r.chain;var C=O(/[0-9]/).desc("a digit");var D=O(/[0-9]*/).desc("optional digits");var G=O(/[a-z]/i).desc("a letter");var H=O(/[a-z]*/i).desc("optional letters");var J=O(/\\s*/).desc("optional whitespace");var K=O(/\\s+/).desc("whitespace");n.all=q;n.alt=x;n.any=z;n.custom=m;n.digit=C;n.digits=D;n.eof=M;n.fail=P;n.formatError=p;n.index=L;n.isParser=t;n.lazy=W;n.letter=G;n.letters=H;n.lookahead=A;n.makeFailure=u;n.makeSuccess=e;n.noneOf=B;n.oneOf=j;n.optWhitespace=J;n.Parser=n;n.regex=O;n.regexp=O;n.sepBy=y;n.sepBy1=w;n.seq=d;n.seqMap=g;n.string=E;n.succeed=b;n.takeWhile=F;n.test=R;n.whitespace=K;n.empty=S;n["fantasy-land/empty"]=S;n.of=b;n["fantasy-land/of"]=b;return n});\n\n\n//# sourceURL=webpack://JGShell/../node_modules/parsimmon/build/parsimmon.browser.min.js?')},"../node_modules/webpack/buildin/module.js":
/*!*************************************************!*\
  !*** ../node_modules/webpack/buildin/module.js ***!
  \*************************************************/
/*! no static exports found */function(module,exports){eval('module.exports = function(module) {\r\n\tif (!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tif (!module.children) module.children = [];\r\n\t\tObject.defineProperty(module, "loaded", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.l;\r\n\t\t\t}\r\n\t\t});\r\n\t\tObject.defineProperty(module, "id", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.i;\r\n\t\t\t}\r\n\t\t});\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n};\r\n\n\n//# sourceURL=webpack://JGShell/../node_modules/webpack/buildin/module.js?')},"./Commands/CommandStructures.js":
/*!***************************************!*\
  !*** ./Commands/CommandStructures.js ***!
  \***************************************/
/*! exports provided: Cd, Rm, Mk, Link, SetTag, SetValue, Search, Refine, Apply, Unparameterised, Import, EdgeData */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Cd", function() { return Cd; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Rm", function() { return Rm; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Mk", function() { return Mk; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Link", function() { return Link; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SetTag", function() { return SetTag; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SetValue", function() { return SetValue; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Search", function() { return Search; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Refine", function() { return Refine; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Apply", function() { return Apply; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Unparameterised", function() { return Unparameterised; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Import", function() { return Import; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EdgeData", function() { return EdgeData; });\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\n/**\n   Data structures for intercommunication between parser and shell\n*/\nvar Cd = //Change the directory to the specified node id\nfunction Cd(id) {\n  _classCallCheck(this, Cd);\n\n  this.id = id;\n};\n\nvar Rm = //Delete the specified id\nfunction Rm() {\n  _classCallCheck(this, Rm);\n\n  for (var _len = arguments.length, ids = new Array(_len), _key = 0; _key < _len; _key++) {\n    ids[_key] = arguments[_key];\n  }\n\n  this.ids = ids;\n};\n\nvar Mk = //Make new nodes with the following names\nfunction Mk() {\n  _classCallCheck(this, Mk);\n\n  for (var _len2 = arguments.length, names = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    names[_key2] = arguments[_key2];\n  }\n\n  this.names = names;\n};\n\nvar EdgeData = function EdgeData() {\n  var _this = this;\n\n  var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n  _classCallCheck(this, EdgeData);\n\n  this.id = id;\n  this.tags = new Set();\n  this.vals = new Map();\n\n  if (data instanceof Array) {\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = data[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var val = _step.value;\n\n        if (val instanceof SetTag) {\n          val.tagNames.forEach(function (d) {\n            return _this.tags.add(d);\n          });\n        } else if (val instanceof SetValue) {\n          this.vals.set(val.valName, val.value);\n        } else {\n          throw new Error(\'Unrecognised val list member\');\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n  } else if (data.tags !== null && data.vals !== null) {\n    this.tags = new Set(data.tags);\n    this.vals = new Map(data.vals);\n  }\n};\n\nvar Link = //Create an edge between two nodes\nfunction Link(sourceData, edgeData, destData) {\n  _classCallCheck(this, Link);\n\n  this.sourceData = sourceData;\n  this.edgeData = edgeData;\n  this.destData = destData;\n};\n\nvar SetTag = //set the tag of a node\nfunction SetTag(tagName) {\n  _classCallCheck(this, SetTag);\n\n  this.tagNames = tagName;\n};\n\nvar SetValue = //set the value of a node\nfunction SetValue(valName, value) {\n  _classCallCheck(this, SetValue);\n\n  this.valName = valName;\n  this.value = value;\n};\n\nvar Search = //Search for a pattern\n//ie: search id 5\n//search value name blah <-- type=value, name=variable, value=blah\nfunction Search(type, variable) {\n  var value = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n  _classCallCheck(this, Search);\n\n  this.type = type;\n  this.variable = variable;\n  this.value = value;\n};\n\nvar Refine = //search within a search\nfunction Refine(type, variable) {\n  var value = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n  _classCallCheck(this, Refine);\n\n  this.type = type;\n  this.variable = variable;\n  this.value = value;\n};\n\nvar Apply = //Apply a command to a search set\nfunction Apply(command) {\n  _classCallCheck(this, Apply);\n\n  this.command = command;\n};\n\nvar Import = //Import a given json string into the shell\nfunction Import(text) {\n  _classCallCheck(this, Import);\n\n  this.text = text;\n};\n\nvar Unparameterised = //stash/unstash/root/cwd/help/export/prior/clear/select\nfunction Unparameterised(name) {\n  _classCallCheck(this, Unparameterised);\n\n  this.name = name;\n};\n\n\n\n//# sourceURL=webpack://JGShell/./Commands/CommandStructures.js?')},"./Edge.js":
/*!*****************!*\
  !*** ./Edge.js ***!
  \*****************/
/*! exports provided: default */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Edge; });\n/* harmony import */ var _Commands_CommandStructures__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Commands/CommandStructures */ "./Commands/CommandStructures.js");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\n\n/**\n   The Edge definition object\n   //sourceDetails -> edgeDetails -> destDetails\n */\n\nvar Edge = function Edge(sourceDetails) {\n  var edgeDetails = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var destDetails = arguments.length > 2 ? arguments[2] : undefined;\n\n  _classCallCheck(this, Edge);\n\n  if (!(sourceDetails instanceof _Commands_CommandStructures__WEBPACK_IMPORTED_MODULE_0__["EdgeData"])) {\n    throw new Error(\'Source Details need to be EdgeData\');\n  }\n\n  if (!(edgeDetails instanceof _Commands_CommandStructures__WEBPACK_IMPORTED_MODULE_0__["EdgeData"]) && edgeDetails !== null) {\n    throw new Error(\'Edge Details need to be edge data\');\n  }\n\n  if (!(destDetails instanceof _Commands_CommandStructures__WEBPACK_IMPORTED_MODULE_0__["EdgeData"])) {\n    throw new Error(\'Dest Details need to be edge data\');\n  } //Each param is an object\n  //only *requirement* is source and dest must have ids\n\n\n  this.source = sourceDetails;\n  this.edge = edgeDetails || new _Commands_CommandStructures__WEBPACK_IMPORTED_MODULE_0__["EdgeData"]();\n  this.dest = destDetails;\n\n  if (sourceDetails === undefined || destDetails === undefined) {\n    throw new Error(\'Edges must have details passed to them\');\n  }\n\n  if (!(\'id\' in this.source) || !(\'id\' in this.dest)) {\n    throw new Error("Edges must have ids");\n  } // if (!(\'type\' in this.source) || !(\'id\' in this.dest)){\n  //     throw new Error(\'Edges must have types\');\n  // }\n\n};\n\n\n\nEdge.prototype.connectedTo = function (id) {\n  return this.source.id === id || this.dest.id === id;\n};\n\nEdge.prototype.idMatches = function (id, type) {\n  if (/dest/.test(type)) {\n    return this.idMatchesDestination(id);\n  } else if (/source/.test(type)) {\n    return this.idMatchesSource(id);\n  }\n\n  throw new Error("IdMatches was passed an unexpected edge type: ".concat(type));\n};\n\nEdge.prototype.idMatchesSource = function (id) {\n  return this.source.id === id;\n};\n\nEdge.prototype.idMatchesDestination = function (id) {\n  return this.dest.id === id;\n}; //Saving and loading:\n\n\nEdge.prototype.toJSONCompatibleObj = function () {\n  var obj = {\n    sourceData: {\n      id: this.source.id,\n      tags: Array.from(this.source.tags),\n      vals: Array.from(this.source.vals)\n    },\n    edgeData: {\n      id: this.edge.id,\n      tags: Array.from(this.edge.tags),\n      vals: Array.from(this.edge.vals)\n    },\n    destData: {\n      id: this.dest.id,\n      tags: Array.from(this.dest.tags),\n      vals: Array.from(this.dest.vals)\n    }\n  };\n  return obj;\n};\n\nEdge.fromJSON = function (obj) {\n  var sourceObj = new _Commands_CommandStructures__WEBPACK_IMPORTED_MODULE_0__["EdgeData"](obj.sourceData.id, obj.sourceData),\n      edgeObj = new _Commands_CommandStructures__WEBPACK_IMPORTED_MODULE_0__["EdgeData"](obj.edgeData.id, obj.edgeData),\n      destObj = new _Commands_CommandStructures__WEBPACK_IMPORTED_MODULE_0__["EdgeData"](obj.destData.id, obj.destData);\n  return [sourceObj, edgeObj, destObj];\n};\n\n//# sourceURL=webpack://JGShell/./Edge.js?')},"./Node/Constructors.js":
/*!******************************!*\
  !*** ./Node/Constructors.js ***!
  \******************************/
/*! exports provided: default */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash */ "lodash");\n/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _GraphNode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GraphNode */ "./Node/GraphNode.js");\n\n\n/**\n    Aggregates the constructors toget\n    @module Node/Constructors\n*/\n\nvar ctors = new Map([["graphnode", _GraphNode__WEBPACK_IMPORTED_MODULE_1__["default"]]]);\n/**\n   Get the Constructor specified\n   @function\n   @param name\n*/\n\nvar getCtor = function getCtor(name) {\n  if (name !== undefined && ctors.has(name.toLowerCase())) {\n    return ctors.get(name.toLowerCase());\n  }\n\n  return ctors.get("graphnode");\n};\n\n/* harmony default export */ __webpack_exports__["default"] = (getCtor);\n\n//# sourceURL=webpack://JGShell/./Node/Constructors.js?')},"./Node/GraphNode.js":
/*!***************************!*\
  !*** ./Node/GraphNode.js ***!
  \***************************/
/*! exports provided: default */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return GraphNode; });\n/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash */ "lodash");\n/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ "./utils.js");\n/* harmony import */ var _Edge__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Edge */ "./Edge.js");\n/* harmony import */ var _Commands_CommandStructures__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Commands/CommandStructures */ "./Commands/CommandStructures.js");\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\n/**\n   The main node type of the graph\n   @module Node/GraphNode\n   @see GraphNode\n*/\n\n\n\n\nvar nextId = 1; //TODO: create an edge data structure.\n//of form start->edgeData->end\n\n/**\n   A node of the overall graph\n   @constructor\n   @alias GraphNode\n*/\n\nvar GraphNode = function GraphNode() {\n  var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  var parentId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var overRideId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n  _classCallCheck(this, GraphNode);\n\n  //Note: relationstoCreate = { children: [{name,children,parents}], parents : [{}] }\n  name = name || "anon";\n  this.id = overRideId || nextId++;\n\n  if (overRideId && overRideId > nextId) {\n    nextId = overRideId + 1;\n  } //Map<id,Edge[]>\n\n\n  this._edges = new Map(); //Map<id,string|number>\n\n  this._values = new Map(); //Set<string>\n\n  this._tags = new Set();\n  this.minimised = false;\n  this.tag(\'graphnode\');\n  this.setValue(\'name\', name); //for root connecting to itself\n\n  if (parentId === -1) {\n    parentId = this.id;\n  }\n\n  if (parentId !== undefined && parentId !== null) {\n    this.setEdge(parentId, new _Commands_CommandStructures__WEBPACK_IMPORTED_MODULE_3__["EdgeData"](parentId, new Set(), new Map()), new _Commands_CommandStructures__WEBPACK_IMPORTED_MODULE_3__["EdgeData"](), new _Commands_CommandStructures__WEBPACK_IMPORTED_MODULE_3__["EdgeData"](this.id, new Set(), new Map()));\n    this.setValue(\'_parentId\', parentId);\n  }\n};\n\n\n\nGraphNode.prototype.toJSONCompatibleObj = function () {\n  var returnObj = {\n    id: this.id,\n    edges: Array.from(this._edges.values()).map(function (e) {\n      return e.toJSONCompatibleObj();\n    }),\n    values: Array.from(this._values),\n    tags: Array.from(this._tags)\n  };\n  return returnObj;\n};\n\nGraphNode.fromJSON = function (obj) {\n  var newNode = new GraphNode(null, null, obj.id);\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = obj.edges[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var edge = _step.value;\n      var newEdgeData = _Edge__WEBPACK_IMPORTED_MODULE_2__["default"].fromJSON(edge),\n          target = null;\n\n      if (newEdgeData[0].id === obj.id) {\n        target = newEdgeData[2].id;\n      } else {\n        target = newEdgeData[0].id;\n      }\n\n      newNode.setEdge.apply(newNode, [target].concat(_toConsumableArray(newEdgeData)));\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  newNode._values = new Map(obj.values);\n  newNode._tags = new Set(obj.tags);\n  return newNode;\n};\n\nGraphNode.prototype.getParents = function () {\n  var _this = this;\n\n  var parents = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.filter(Array.from(this._edges.values()), function (d) {\n    return d.dest.id === _this.id;\n  });\n\n  return parents;\n};\n\nGraphNode.prototype.getChildren = function () {\n  var _this2 = this;\n\n  var children = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.filter(Array.from(this._edges.values()), function (d) {\n    return d.source.id === _this2.id;\n  });\n\n  return children;\n};\n\nGraphNode.prototype.toString = function () {\n  return "(".concat(this.id, ") : ").concat(this.name._slice(0, 10));\n};\n\nGraphNode.prototype.setEdge = function (id, sourceData, edgeData, destData) {\n  //todo: use Edge Data type\n  if (sourceData.id === null) {\n    sourceData.id = this.id;\n  } else if (destData.id === null) {\n    destData.id = this.id;\n  }\n\n  if (id !== sourceData.id && id !== destData.id) {\n    console.log("Inconsistent Edge data:", sourceData, destData);\n    throw new Error(\'Specified an id for an edge that is inconsistent\');\n  }\n\n  if (this.id !== sourceData.id && this.id !== destData.id) {\n    console.log(\'Unconnected Target node:\'.sourceData, destData);\n    throw new Error(\'Specified an edge unconnected to the targeted node\');\n  }\n\n  var newEdge = new _Edge__WEBPACK_IMPORTED_MODULE_2__["default"](sourceData, edgeData, destData);\n\n  this._edges.set(id, newEdge);\n\n  return this;\n};\n\nGraphNode.prototype.getEdgeTo = function (id) {\n  if (id instanceof GraphNode) {\n    id = id.id;\n  }\n\n  if (!this.hasEdgeWith(id)) {\n    throw new Error(\'Node does not have specified edge\');\n  }\n\n  return this._edges.get(id);\n};\n\nGraphNode.prototype.removeEdge = function (id) {\n  if (id instanceof GraphNode) {\n    id = id.id;\n  }\n\n  if (!this.hasEdgeWith(id)) {\n    throw new Error("Can\'t remove an edge that doesn\'t exist");\n  }\n\n  this._edges.delete(id);\n\n  return this;\n};\n\nGraphNode.prototype.numOfEdges = function () {\n  return this._edges.size;\n};\n\nGraphNode.prototype.hasEdgeWith = function (id) {\n  if (id instanceof GraphNode) {\n    id = id.id;\n  }\n\n  if (this._edges.has(id)) {\n    return true;\n  }\n\n  return false;\n};\n\nGraphNode.prototype.name = function () {\n  return this.getValue(\'name\');\n};\n\nGraphNode.prototype.setName = function (newName) {\n  this.setValue(\'name\', newName);\n  return this;\n}; //TODO:\n//set values\n\n\nGraphNode.prototype.setValue = function (key, value) {\n  if (value !== undefined && value !== null) {\n    this._values.set(key, value);\n  } else {\n    this._values.delete(key);\n  }\n\n  return this;\n};\n\nGraphNode.prototype.hasValue = function (key) {\n  return this._values.has(key);\n};\n\nGraphNode.prototype.getValue = function (key) {\n  if (!this._values.has(key)) {\n    throw new Error("Can\'t get a value for a non-existent key");\n  }\n\n  return this._values.get(key);\n};\n\nGraphNode.prototype.values = function () {\n  return Array.from(this._values);\n}; //set annotations\n//set tags\n\n\nGraphNode.prototype.tags = function () {\n  return Array.from(this._tags);\n};\n\nGraphNode.prototype.hasTag = function (tag) {\n  return this._tags.has(tag);\n};\n\nGraphNode.prototype.tag = function (tag) {\n  this._tags.add(tag);\n\n  return this;\n};\n\nGraphNode.prototype.tagToggle = function (tag) {\n  if (this.hasTag(tag)) {\n    this.untag(tag);\n  } else {\n    this._tags.add(tag);\n  }\n\n  return this;\n};\n\nGraphNode.prototype.untag = function (tag) {\n  this._tags.delete(tag);\n\n  return this;\n}; //minimise/uniminimise\n\n//# sourceURL=webpack://JGShell/./Node/GraphNode.js?')},"./PParse.js":
/*!*******************!*\
  !*** ./PParse.js ***!
  \*******************/
/*! exports provided: default */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var parsimmon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! parsimmon */ "../node_modules/parsimmon/build/parsimmon.browser.min.js");\n/* harmony import */ var parsimmon__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(parsimmon__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _Commands_CommandStructures__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Commands/CommandStructures */ "./Commands/CommandStructures.js");\nfunction isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\n/* eslint camelcase: "off" */\n\n/*\n  Parsimmon based parsing\n*/\n\n //Utility\n//Optional whitespace wrapper:\n\nvar OWS = function OWS(parser) {\n  return parsimmon__WEBPACK_IMPORTED_MODULE_0__["optWhitespace"].then(parser).skip(parsimmon__WEBPACK_IMPORTED_MODULE_0__["optWhitespace"]);\n},\n    //non-optional whitespace sequence\nPWS = function PWS(parser) {\n  return parser.skip(parsimmon__WEBPACK_IMPORTED_MODULE_0__["whitespace"]);\n},\n    WPW = function WPW(parser) {\n  return parsimmon__WEBPACK_IMPORTED_MODULE_0__["whitespace"].then(parser).skip(parsimmon__WEBPACK_IMPORTED_MODULE_0__["whitespace"]);\n}; //Simple unparameterised parsing:\n\n\nvar unparameterisedCmnds = "unstash stash root cwd help export prior clear select",\n    unParParsers = parsimmon__WEBPACK_IMPORTED_MODULE_0__["alt"].apply(parsimmon__WEBPACK_IMPORTED_MODULE_0__, _toConsumableArray(unparameterisedCmnds.split(\' \').map(function (d) {\n  return parsimmon__WEBPACK_IMPORTED_MODULE_0__["string"](d);\n}))),\n    UPP_Results = unParParsers.map(function (r) {\n  return new _Commands_CommandStructures__WEBPACK_IMPORTED_MODULE_1__["Unparameterised"](r);\n}); //Parameterised Command Literals\n//Short Command literals:\n\nvar SHORT_TAG = parsimmon__WEBPACK_IMPORTED_MODULE_0__["string"](\'#\'),\n    SHORT_VAL = parsimmon__WEBPACK_IMPORTED_MODULE_0__["string"](\'$\'),\n    COLON = PWS(parsimmon__WEBPACK_IMPORTED_MODULE_0__["string"](\':\')),\n    SHORT_LINK = parsimmon__WEBPACK_IMPORTED_MODULE_0__["string"](\'>\'),\n    SHORT_CD = parsimmon__WEBPACK_IMPORTED_MODULE_0__["string"](\'@\'),\n    SHORT_PRIOR = parsimmon__WEBPACK_IMPORTED_MODULE_0__["string"](\'<\'),\n    //long command literals\nCD = PWS(parsimmon__WEBPACK_IMPORTED_MODULE_0__["alt"](parsimmon__WEBPACK_IMPORTED_MODULE_0__["string"](\'cd\'), SHORT_CD)),\n    MK = PWS(parsimmon__WEBPACK_IMPORTED_MODULE_0__["string"](\'mk\')),\n    LINK = PWS(parsimmon__WEBPACK_IMPORTED_MODULE_0__["string"](\'link\')),\n    RM = PWS(parsimmon__WEBPACK_IMPORTED_MODULE_0__["string"](\'rm\')),\n    SET = PWS(parsimmon__WEBPACK_IMPORTED_MODULE_0__["string"](\'set\')),\n    TAG = PWS(parsimmon__WEBPACK_IMPORTED_MODULE_0__["alt"](parsimmon__WEBPACK_IMPORTED_MODULE_0__["string"](\'tag\'), SHORT_TAG)),\n    VALUE = PWS(parsimmon__WEBPACK_IMPORTED_MODULE_0__["alt"](parsimmon__WEBPACK_IMPORTED_MODULE_0__["string"](\'value\'), SHORT_VAL)),\n    SEARCH = PWS(parsimmon__WEBPACK_IMPORTED_MODULE_0__["string"](\'search\')),\n    REFINE = PWS(parsimmon__WEBPACK_IMPORTED_MODULE_0__["string"](\'refine\')),\n    APPLY = PWS(parsimmon__WEBPACK_IMPORTED_MODULE_0__["string"](\'apply\')),\n    IMPORT = PWS(parsimmon__WEBPACK_IMPORTED_MODULE_0__["string"](\'import\')); //Values\n\nvar str_val = OWS(parsimmon__WEBPACK_IMPORTED_MODULE_0__["regex"](/[a-zA-Z][a-zA-Z0-9_$]*/)),\n    str_lit = parsimmon__WEBPACK_IMPORTED_MODULE_0__["string"](\'"\').then(parsimmon__WEBPACK_IMPORTED_MODULE_0__["regex"](/[a-zA-Z0-9\\- \'$%{}&;:.[]()]+/)).skip(parsimmon__WEBPACK_IMPORTED_MODULE_0__["string"](\'"\')),\n    id = OWS(parsimmon__WEBPACK_IMPORTED_MODULE_0__["regex"](/[0-9]+/).map(Number)),\n    parent = OWS(parsimmon__WEBPACK_IMPORTED_MODULE_0__["string"](\'..\')),\n    num = parsimmon__WEBPACK_IMPORTED_MODULE_0__["regex"](/-?[0-9]+(\\.[0-9]+)?/).map(Number),\n    //todo: convert to number\n//Values combined:\ncom_vals = parsimmon__WEBPACK_IMPORTED_MODULE_0__["alt"](str_val, str_lit, num).skip(parsimmon__WEBPACK_IMPORTED_MODULE_0__["optWhitespace"]),\n    //Regular expression... regex:\nregex_term = parsimmon__WEBPACK_IMPORTED_MODULE_0__["string"](\'/\'),\n    regex_core = parsimmon__WEBPACK_IMPORTED_MODULE_0__["regex"](/[ .a-zA-Z\'"0-9-+=_!@#$%^&*()[]|]+/),\n    regex_flags = parsimmon__WEBPACK_IMPORTED_MODULE_0__["regex"](/[gimuy]*/),\n    regex = regex_term.then(parsimmon__WEBPACK_IMPORTED_MODULE_0__["seqMap"](regex_core.skip(regex_term), regex_flags.skip(regex_term), function (r, f) {\n  return RegExp(r, f);\n})).skip(parsimmon__WEBPACK_IMPORTED_MODULE_0__["optWhitespace"]); //Actual commands:\n\nvar cd_cmd = CD.then(parsimmon__WEBPACK_IMPORTED_MODULE_0__["alt"](id, parent, str_val)).map(function (r) {\n  return new _Commands_CommandStructures__WEBPACK_IMPORTED_MODULE_1__["Cd"](r);\n}),\n    mk_cmd = MK.then(str_val.many()).map(function (rs) {\n  return _construct(_Commands_CommandStructures__WEBPACK_IMPORTED_MODULE_1__["Mk"], _toConsumableArray(rs));\n}),\n    rm_cmd = RM.then(id.many()).map(function (ids) {\n  return _construct(_Commands_CommandStructures__WEBPACK_IMPORTED_MODULE_1__["Rm"], _toConsumableArray(ids));\n}),\n    set_tag_cmd = SET.then(TAG).then(str_val.many()).map(function (r) {\n  return new _Commands_CommandStructures__WEBPACK_IMPORTED_MODULE_1__["SetTag"](r);\n}),\n    set_val_cmd = SET.then(VALUE).then(parsimmon__WEBPACK_IMPORTED_MODULE_0__["seqMap"](str_val, com_vals, function (a, b) {\n  return new _Commands_CommandStructures__WEBPACK_IMPORTED_MODULE_1__["SetValue"](a, b);\n})),\n    import_cmd = IMPORT.then(parsimmon__WEBPACK_IMPORTED_MODULE_0__["all"]).map(function (t) {\n  return new _Commands_CommandStructures__WEBPACK_IMPORTED_MODULE_1__["Import"](t);\n}),\n    //Short commands\nshort_tag_cmd = SHORT_TAG.then(str_val).map(function (r) {\n  return new _Commands_CommandStructures__WEBPACK_IMPORTED_MODULE_1__["SetTag"]([r]);\n}),\n    short_val_cmd = SHORT_VAL.then(parsimmon__WEBPACK_IMPORTED_MODULE_0__["seqMap"](str_val.skip(OWS(COLON)), parsimmon__WEBPACK_IMPORTED_MODULE_0__["alt"](com_vals, parsimmon__WEBPACK_IMPORTED_MODULE_0__["succeed"](null)), function (a, b) {\n  return new _Commands_CommandStructures__WEBPACK_IMPORTED_MODULE_1__["SetValue"](a, b);\n})); //4($blah:bloo) > 2() > 8(#blah, $awef:aweji)\n\nvar paramsList = parsimmon__WEBPACK_IMPORTED_MODULE_0__["string"](\'(\').then(parsimmon__WEBPACK_IMPORTED_MODULE_0__["sepBy"](parsimmon__WEBPACK_IMPORTED_MODULE_0__["alt"](short_tag_cmd, short_val_cmd), OWS(parsimmon__WEBPACK_IMPORTED_MODULE_0__["string"](\',\')))).skip(parsimmon__WEBPACK_IMPORTED_MODULE_0__["string"](\')\')),\n    idValList = parsimmon__WEBPACK_IMPORTED_MODULE_0__["seqMap"](id, paramsList.or(parsimmon__WEBPACK_IMPORTED_MODULE_0__["alt"](parsimmon__WEBPACK_IMPORTED_MODULE_0__["optWhitespace"], parsimmon__WEBPACK_IMPORTED_MODULE_0__["string"](\'()\')).result([])), function (i, vs) {\n  return new _Commands_CommandStructures__WEBPACK_IMPORTED_MODULE_1__["EdgeData"](i, vs);\n}); //*must* have a source and dest, *may* have an edge id\n\nvar new_link_cmd = parsimmon__WEBPACK_IMPORTED_MODULE_0__["seqMap"](idValList.skip(OWS(SHORT_LINK)), idValList.or(parsimmon__WEBPACK_IMPORTED_MODULE_0__["alt"](parsimmon__WEBPACK_IMPORTED_MODULE_0__["optWhitespace"], parsimmon__WEBPACK_IMPORTED_MODULE_0__["string"](\'()\')).result(new _Commands_CommandStructures__WEBPACK_IMPORTED_MODULE_1__["EdgeData"]())).skip(OWS(SHORT_LINK)), idValList, function (s, e, d) {\n  return new _Commands_CommandStructures__WEBPACK_IMPORTED_MODULE_1__["Link"](s, e, d);\n});\nvar short_cd_cmd = SHORT_CD.then(parsimmon__WEBPACK_IMPORTED_MODULE_0__["alt"](id, parent, str_val)).map(function (r) {\n  return new _Commands_CommandStructures__WEBPACK_IMPORTED_MODULE_1__["Cd"](r);\n}),\n    short_prior_cmd = SHORT_PRIOR.then(parsimmon__WEBPACK_IMPORTED_MODULE_0__["eof"]).map(function () {\n  return new _Commands_CommandStructures__WEBPACK_IMPORTED_MODULE_1__["Unparameterised"](\'prior\');\n}); //Searching and Refining:\n//Searching:\n//TODO: add eval function for value searching, edge type specification\n\nvar search_cmd_short = SEARCH.then(parsimmon__WEBPACK_IMPORTED_MODULE_0__["seqMap"](str_val, regex, function (v, r) {\n  return new _Commands_CommandStructures__WEBPACK_IMPORTED_MODULE_1__["Search"](v, r);\n})),\n    search_cmd_long = SEARCH.then(parsimmon__WEBPACK_IMPORTED_MODULE_0__["seqMap"](str_val, parsimmon__WEBPACK_IMPORTED_MODULE_0__["alt"](str_val, regex), parsimmon__WEBPACK_IMPORTED_MODULE_0__["alt"](id, regex), function (v, r, r2) {\n  return new _Commands_CommandStructures__WEBPACK_IMPORTED_MODULE_1__["Search"](v, r, r2);\n})),\n    //Refining:\nrefine_cmd_short = REFINE.then(parsimmon__WEBPACK_IMPORTED_MODULE_0__["seqMap"](str_val, regex, function (v, r) {\n  return new _Commands_CommandStructures__WEBPACK_IMPORTED_MODULE_1__["Refine"](v, r);\n})),\n    refine_cmd_long = REFINE.then(parsimmon__WEBPACK_IMPORTED_MODULE_0__["seqMap"](str_val, regex, regex, function (v, r, r2) {\n  return new _Commands_CommandStructures__WEBPACK_IMPORTED_MODULE_1__["Refine"](v, r, r2);\n})); //Aggregates\n\nvar cmd_list = parsimmon__WEBPACK_IMPORTED_MODULE_0__["alt"](mk_cmd, rm_cmd, set_tag_cmd, set_val_cmd, search_cmd_long, search_cmd_short, refine_cmd_long, refine_cmd_short);\nvar short_cmd_list = parsimmon__WEBPACK_IMPORTED_MODULE_0__["alt"](short_tag_cmd, short_val_cmd, short_cd_cmd, short_prior_cmd, new_link_cmd);\nvar apply_cmd = APPLY.then(parsimmon__WEBPACK_IMPORTED_MODULE_0__["alt"](short_cmd_list, cmd_list)).map(function (cmd) {\n  return new _Commands_CommandStructures__WEBPACK_IMPORTED_MODULE_1__["Apply"](cmd);\n});\nvar ROOT = parsimmon__WEBPACK_IMPORTED_MODULE_0__["alt"](apply_cmd, short_cmd_list, cd_cmd, import_cmd, UPP_Results, cmd_list);\n/* harmony default export */ __webpack_exports__["default"] = (ROOT);\n/*\n  search id {number}\n  search name {regex}\n  search tag {regex}\n  search value {regex}\n  search value {regex} {regex}\n  refine name {regex}\n  refine tag {regex}\n  refine value {regex}\n  refine value {regex} {regex}\n  apply {command}\n*/\n\n//# sourceURL=webpack://JGShell/./PParse.js?')},"./Shell.js":
/*!******************!*\
  !*** ./Shell.js ***!
  \******************/
/*! exports provided: default */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Shell; });\n/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash */ "lodash");\n/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _libs_rete__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../libs/rete */ "../libs/rete.js");\n/* harmony import */ var _libs_rete__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_libs_rete__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _Node_GraphNode__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Node/GraphNode */ "./Node/GraphNode.js");\n/* harmony import */ var _Node_Constructors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Node/Constructors */ "./Node/Constructors.js");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils */ "./utils.js");\n/* harmony import */ var _PParse__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./PParse */ "./PParse.js");\n/* harmony import */ var _Commands_CommandStructures__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Commands/CommandStructures */ "./Commands/CommandStructures.js");\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }\n\nfunction _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\n\n\n\n\n\n\n\n/**\n   The Main Shell Class. Provides interaction with the Graph, and the ReteNet.\n   Methods are separated into modules at {@link module:ShellModules/shellPrototype_main shellPrototype_main}\n   @exports Shell\n   @constructor\n   @param {Array} ReteActionsToRegister\n*/\n\nvar Shell = function Shell(ReteActionsToRegister) {\n  _classCallCheck(this, Shell);\n\n  this._root = new _Node_GraphNode__WEBPACK_IMPORTED_MODULE_2__["default"](\'_root\', -1);\n  this._nodes = new Map();\n  this.set(this._root);\n  this._ruleIds = []; //State:\n\n  this._cwd = this._root;\n  this._nodeStash = [];\n  this._previousLocation = [this._root.id]; //Search Results\n\n  this._searchResults = []; //Rete:\n\n  this._reteNet = new _libs_rete__WEBPACK_IMPORTED_MODULE_1___default.a(ReteActionsToRegister);\n  this._reteNetBackupActions = ReteActionsToRegister;\n  this._reteOutput = []; //Simulation\n\n  this._simulation = null; //The parser:\n\n  this._parser = _PParse__WEBPACK_IMPORTED_MODULE_5__["default"];\n}; //Parsing function: returns nullable\n\n\n\n\nShell.prototype.parse = function (string) {\n  var result = this._parser.parse(string);\n\n  if (result.status === false) {\n    console.log(\'Bad Parse:\', result); //todo: draw to screen\n\n    return null;\n  }\n\n  result = result.value;\n  return this.actOnParse(result);\n};\n\nShell.prototype.actOnParse = function (action) {\n  var _this = this;\n\n  switch (action.constructor) {\n    case _Commands_CommandStructures__WEBPACK_IMPORTED_MODULE_6__["Cd"]:\n      this.cdByString(action.id);\n      break;\n\n    case _Commands_CommandStructures__WEBPACK_IMPORTED_MODULE_6__["Rm"]:\n      action.ids.forEach(function (d) {\n        _this.rm(d);\n      });\n      break;\n\n    case _Commands_CommandStructures__WEBPACK_IMPORTED_MODULE_6__["Mk"]:\n      action.names.forEach(function (name) {\n        _this.addNode(name);\n      });\n      break;\n\n    case _Commands_CommandStructures__WEBPACK_IMPORTED_MODULE_6__["Link"]:\n      this.link(action.sourceData, action.edgeData, action.destData);\n      break;\n\n    case _Commands_CommandStructures__WEBPACK_IMPORTED_MODULE_6__["SetTag"]:\n      action.tagNames.forEach(function (t) {\n        return _this.cwd().tagToggle(t);\n      });\n      break;\n\n    case _Commands_CommandStructures__WEBPACK_IMPORTED_MODULE_6__["SetValue"]:\n      this.cwd().setValue(action.valName, action.value);\n      break;\n\n    case _Commands_CommandStructures__WEBPACK_IMPORTED_MODULE_6__["Search"]:\n      this.search(action.type, action.variable, action.value);\n      break;\n\n    case _Commands_CommandStructures__WEBPACK_IMPORTED_MODULE_6__["Refine"]:\n      this.refine(action.type, action.variable, action.value);\n      break;\n\n    case _Commands_CommandStructures__WEBPACK_IMPORTED_MODULE_6__["Apply"]:\n      this.actOnSearchResults(action);\n      break;\n\n    case _Commands_CommandStructures__WEBPACK_IMPORTED_MODULE_6__["Import"]:\n      this.import(action.text);\n      break;\n\n    case _Commands_CommandStructures__WEBPACK_IMPORTED_MODULE_6__["Unparameterised"]:\n      return this.processUnparameterisedCommand(action);\n    //break;\n\n    default:\n      throw new Error(\'Unrecognised command parsed\');\n  }\n\n  return null;\n};\n\nShell.prototype.actOnSearchResults = function (action) {\n  var _this2 = this;\n\n  var searchResults = this.searchResults(),\n      cwdRecall = this.cwd().id;\n\n  if (!(action instanceof _Commands_CommandStructures__WEBPACK_IMPORTED_MODULE_6__["Apply"])) {\n    throw new Error(\'Instructed to apply, without passing a CStructs.Apply\');\n  }\n\n  if (searchResults.length === 0) {\n    throw new Error(\'Instructed to act on empty search results\');\n  }\n\n  searchResults.forEach(function (d) {\n    _this2.cdById(d);\n\n    _this2.actOnParse(action.command);\n  });\n  this.cdById(cwdRecall);\n}; //Deal with unparameterised commands\n\n\nShell.prototype.processUnparameterisedCommand = function (command) {\n  switch (command.name) {\n    case \'export\':\n      return this.export();\n    //break;\n\n    case \'stash\':\n      this.stash();\n      break;\n\n    case \'unstash\':\n      this.unstash();\n      break;\n\n    case \'root\':\n      this.cdById(this._root.id);\n      break;\n\n    case \'cwd\':\n      return this.printState();\n    //break;\n\n    case \'help\':\n      return this.help();\n    //break;\n\n    case \'prior\':\n      this.cdById(this.prior());\n      break;\n\n    case \'clear\':\n      this._searchResults = [];\n      break;\n\n    case \'select\':\n      this._searchResults.push(this.cwd().id);\n\n      break;\n\n    default:\n      throw new Error("Unrecognised Unparameterised Command: ".concat(command.name));\n  }\n\n  return null;\n};\n/** Get A Node Constructor by name. @see Node/Constructors */\n\n\nShell.prototype.getCtor = _Node_Constructors__WEBPACK_IMPORTED_MODULE_3__["default"]; //Utilities\n\nShell.prototype.length = function () {\n  return this._nodes.size;\n};\n\nShell.prototype.numRules = function () {\n  return this._ruleIds.length;\n}; //Check a node/id exists\n\n\nShell.prototype.has = function (id) {\n  if (id instanceof _Node_GraphNode__WEBPACK_IMPORTED_MODULE_2__["default"]) {\n    id = id.id;\n  }\n\n  return this._nodes.has(id);\n}; //Retrieve a specific node\n\n\nShell.prototype.get = function (id) {\n  if (this.has(Number(id))) {\n    return this._nodes.get(Number(id));\n  }\n\n  throw new Error("Node ".concat(id, " does not exist"));\n}; //Add a newly created node to the shell\n\n\nShell.prototype.set = function (node) {\n  if (!(node instanceof _Node_GraphNode__WEBPACK_IMPORTED_MODULE_2__["default"])) {\n    throw new Error(\'Cannot add a non-GraphNode\');\n  }\n\n  if (this.has(node.id)) {\n    console.log(this._nodes);\n    throw new Error("Cannot replace already existing nodes: ".concat(node.id));\n  }\n\n  this._nodes.set(node.id, node);\n}; //Delete a node, including all its edges\n\n\nShell.prototype.rm = function (id) {\n  if (id instanceof _Node_GraphNode__WEBPACK_IMPORTED_MODULE_2__["default"]) {\n    id = id.id;\n  }\n\n  if (!this.has(id)) {\n    throw new Error("Can\'t remove a node that doesn\'t exist");\n  }\n\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = this.get(id)._edges.keys()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var entry = _step.value;\n      this.get(entry).removeEdge(id);\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  this._nodes.delete(id);\n}; //Alias for rm\n\n\nShell.prototype.deleteNode = function (id) {\n  this.rm(id);\n}; //Get the root node of the shell\n\n\nShell.prototype.root = function () {\n  return this._root;\n}; //Get the current working node\n\n\nShell.prototype.cwd = function () {\n  return this._cwd;\n}; //get the node that was the cwd before the current one\n\n\nShell.prototype.prior = function () {\n  return lodash__WEBPACK_IMPORTED_MODULE_0___default.a.last(this._previousLocation);\n}; //Get the saved search results\n\n\nShell.prototype.searchResults = function () {\n  return Array.from(this._searchResults);\n}; //Get the stored results of a rete firing\n\n\nShell.prototype.reteOutput = function () {\n  return Array.from(this._reteOutput);\n}; //Connect two nodes by an edge\n\n\nShell.prototype.link = function (sourceData, edgeData, destData) {\n  var source = this.get(sourceData.id),\n      dest = this.get(destData.id),\n      edge = edgeData.id ? this.get(edgeData.id) : null;\n  source.setEdge(destData.id, sourceData, edgeData, destData);\n  dest.setEdge(sourceData.id, sourceData, edgeData, destData);\n}; //Create a new node\n\n\nShell.prototype.addNode = function (name, destType, sourceType, nodeType, subRelations) {\n  var sourceId = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : undefined;\n  //get the node to link to\n  var source = sourceId ? this.get(sourceId) : this.cwd(); //Configure defaults if necessary:\n\n  if (name === null || name === undefined || name === "") {\n    name = sourceType || "anon";\n  }\n\n  sourceType = sourceType || \'parent\';\n  destType = destType || \'child\';\n  nodeType = nodeType || "graphnode"; //Get the constructor for the type of node\n\n  var ctor = Object(_Node_Constructors__WEBPACK_IMPORTED_MODULE_3__["default"])(nodeType),\n      newNode = new ctor(name, source.id); //Store the new node\n\n  this.set(newNode); //add to cwd/target\n\n  this.link(new _Commands_CommandStructures__WEBPACK_IMPORTED_MODULE_6__["EdgeData"](source.id, {\n    tags: [sourceType],\n    vals: []\n  }), new _Commands_CommandStructures__WEBPACK_IMPORTED_MODULE_6__["EdgeData"](null, {\n    tags: [],\n    vals: []\n  }), new _Commands_CommandStructures__WEBPACK_IMPORTED_MODULE_6__["EdgeData"](newNode.id, {\n    tags: [destType],\n    vals: []\n  }));\n  return newNode.id;\n}; //Enable cd\'ing to a parent with \'cd ..\'\n\n\nShell.prototype.cdByString = function (str) {\n  if (!Number.isNaN(Number(str))) {\n    this.cdById(Number(str));\n    return;\n  }\n\n  if (str.match(/\\.\\./) !== null) {\n    this.cdById(this.cwd().getValue(\'_parentId\'));\n  } else {\n    //Is a String. Find a local node of the correct name to move to\n    throw new Error("Unimplemented: ".concat(str));\n  }\n}; //The typical way of cd\'ing, using the id of the node\n\n\nShell.prototype.cdById = function (id) {\n  if (typeof id !== \'number\') {\n    throw new Error("Cd\'ing needs an id, instead got ".concat(_typeof(id)));\n  }\n\n  if (!this.has(id)) {\n    throw new Error("Can\'t cd to a non-existent node");\n  }\n\n  this._previousLocation.push(this.cwd().id);\n\n  this._cwd = this.get(id);\n}; //Storing the current node to return to later\n\n\nShell.prototype.stash = function () {\n  this._nodeStash.push(this.cwd().id);\n}; //getting rid of a stored node\n\n\nShell.prototype.unstash = function () {\n  return this._nodeStash.pop();\n}; //Get the entire stash\n\n\nShell.prototype.getStash = function () {\n  return lodash__WEBPACK_IMPORTED_MODULE_0___default.a.clone(this._nodeStash);\n}; //convert the shell nodes to a json representation\n\n\nShell.prototype.export = function () {\n  var nodes = [];\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = this._nodes.values()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var node = _step2.value;\n      nodes.push(node.toJSONCompatibleObj());\n    }\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n        _iterator2.return();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n\n  var jsonString = JSON.stringify({\n    nodes: nodes,\n    root: this._root.id\n  });\n  return {\n    description: \'json\',\n    text: jsonString\n  };\n}; //TODO: TWINE EXPORT\n//given json text, parse it and create new nodes and links from it\n\n\nShell.prototype.import = function (text) {\n  var loadedObj = JSON.parse(text);\n  console.log(\'Loading data:\', loadedObj);\n\n  this._nodes.clear();\n\n  var _iteratorNormalCompletion3 = true;\n  var _didIteratorError3 = false;\n  var _iteratorError3 = undefined;\n\n  try {\n    for (var _iterator3 = loadedObj.nodes[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n      var nodeRep = _step3.value;\n      var newNode = _Node_GraphNode__WEBPACK_IMPORTED_MODULE_2__["default"].fromJSON(nodeRep);\n      this.set(newNode);\n    }\n  } catch (err) {\n    _didIteratorError3 = true;\n    _iteratorError3 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n        _iterator3.return();\n      }\n    } finally {\n      if (_didIteratorError3) {\n        throw _iteratorError3;\n      }\n    }\n  }\n\n  this._root = this._nodes.get(loadedObj.root);\n  this._cwd = this._root;\n}; //Include without overwriting\n\n\nShell.prototype.extend = function (text) {//parse json,\n  //create nodes, without overriding the id,\n  //create a map of oldId => newId\n  //go through and modify all edges\n  //link root of new data to root()\n}; //tod: Rete. Run rule, enact...\n//todo: Sim\n//Search, value is nullable, returns nothing, side effect: this._searchResults\n//TODO: sub-method these\n\n\nShell.prototype.search = function (type, variable) {\n  var _this3 = this;\n\n  var value = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  var refine = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var searchBase = [];\n\n  if (!refine) {\n    searchBase = Array.from(this._nodes.values());\n  } else {\n    searchBase = this._searchResults.map(function (d) {\n      return _this3.get(d);\n    });\n  } //go through all nodes, filtering by the tag/varName/varName+varValue\n\n\n  switch (type) {\n    case \'name\':\n      {\n        //\'name\', regex, null\n        if (value !== null || !(variable instanceof RegExp)) {\n          throw new Error(\'Incorrect Name Search\');\n        }\n\n        var nodes = searchBase.filter(function (d) {\n          return variable.test(d.name());\n        });\n        this._searchResults = nodes.map(function (d) {\n          return d.id;\n        });\n      }\n      break;\n\n    case \'tag\':\n      {\n        //\'tag\', regex, null\n        if (value !== null || !(variable instanceof RegExp)) {\n          throw new Error(\'Incorrect Tag Search\');\n        }\n\n        var nodeTagPairs = searchBase.map(function (d) {\n          return [d.id, d.tags()];\n        }),\n            filteredPairs = nodeTagPairs.filter(function (_ref) {\n          var _ref2 = _slicedToArray(_ref, 2),\n              id = _ref2[0],\n              tags = _ref2[1];\n\n          return lodash__WEBPACK_IMPORTED_MODULE_0___default.a.some(tags, function (x) {\n            return variable.test(x);\n          });\n        }),\n            finalIds = filteredPairs.map(function (_ref3) {\n          var _ref4 = _slicedToArray(_ref3, 2),\n              id = _ref4[0],\n              tags = _ref4[1];\n\n          return id;\n        });\n        this._searchResults = finalIds;\n      }\n      break;\n\n    case \'value\':\n      {\n        //\'value\', regex, regex\n        if (variable instanceof RegExp && value !== null && value instanceof RegExp) {\n          //get all nodes with passing value names\n          var variableMatches = searchBase.filter(function (d) {\n            return lodash__WEBPACK_IMPORTED_MODULE_0___default.a.some(d.values(), function (_ref5) {\n              var _ref6 = _slicedToArray(_ref5, 2),\n                  vi = _ref6[0],\n                  va = _ref6[1];\n\n              return variable.test(vi) && value.test(va);\n            });\n          });\n          this._searchResults = variableMatches.map(function (d) {\n            return d.id;\n          });\n        } else if (variable instanceof RegExp && value === null) {\n          var _variableMatches = searchBase.filter(function (d) {\n            return lodash__WEBPACK_IMPORTED_MODULE_0___default.a.some(d.values(), function (_ref7) {\n              var _ref8 = _slicedToArray(_ref7, 2),\n                  k = _ref8[0],\n                  v = _ref8[1];\n\n              return variable.test(k);\n            });\n          });\n\n          this._searchResults = _variableMatches.map(function (d) {\n            return d.id;\n          }); //TODO: add logic for value being an EXPRESSION\n        } else if (!(variable instanceof RegExp) && value === null) {\n          var hasVariable = searchBase.filter(function (d) {\n            return d.hasValue(variable);\n          });\n          this._searchResults = hasVariable.map(function (d) {\n            return d.id;\n          });\n        } else if (!(variable instanceof RegExp) && value !== null && !(value instanceof RegExp)) {\n          var hasExactVariable = searchBase.filter(function (d) {\n            return d.hasValue(variable) && d.getValue(variable) === value;\n          });\n          this._searchResults = hasExactVariable.map(function (d) {\n            return d.id;\n          });\n        } else {\n          throw new Error("Unrecognised search attempt");\n        }\n      }\n      break;\n\n    case \'edge\':\n      {\n        //\'edge\', \'dest\'/\'source\', id\n        //TODO: enable more edge types\n        if (value === null || !/dest|source/.test(variable)) {\n          throw new Error(\'Incorrect Edge Search\');\n        } //filter all nodes by their edges, with the id in the dest/source slot\n\n\n        var linkedNodes = searchBase.filter(function (d) {\n          return d.hasEdgeWith(value) && d.getEdgeTo(value).idMatches(value, variable);\n        });\n        this._searchResults = linkedNodes.map(function (d) {\n          return d.id;\n        });\n      }\n      break;\n\n    default:\n      throw new Error(\'Incorrect Search Specified\');\n  }\n}; //Apply a search to search results instead of the main shell\n\n\nShell.prototype.refine = function (type, variable, value) {\n  return this.search(type, variable, value, true);\n}; //TODO: Graph search\n\n\nShell.prototype.dfs = function () {\n  throw new Error(\'Unimplemented: DFS\');\n};\n\nShell.prototype.bfs = function () {\n  throw new Error(\'Unimplemented: BFS\');\n}; //TODO: Help:\n\n\nShell.prototype.help = function () {\n  var data = {\n    description: "help"\n  };\n  throw new Error(\'Unimplemented: Help\');\n}; //Utility to get the path from the root to the current directory\n\n\nShell.prototype.getPath = function () {\n  var path = [],\n      current = this.cwd();\n\n  while (current.id !== this._root.id && current.getValue(\'_parentId\') !== current.id) {\n    path.unshift([current.name(), current.id]);\n    current = this.get(current.getValue(\'_parentId\'));\n  }\n\n  path.unshift([this._root.name(), this._root.id]);\n  return path;\n}; //Output information about the current state in a way for the preactShell to visualise\n\n\nShell.prototype.printState = function () {\n  var node = this.cwd(),\n      inputs = node.getParents(),\n      outputs = node.getChildren(),\n      prevSearches = this.searchResults(),\n      currPath = this.getPath(),\n      stash = this.getStash();\n  return {\n    description: \'stateDescription\',\n    inputs: inputs,\n    node: node,\n    outputs: outputs,\n    searchResults: prevSearches,\n    currentPath: currPath,\n    stash: stash\n  };\n};\n\n//# sourceURL=webpack://JGShell/./Shell.js?')},"./utils.js":
/*!******************!*\
  !*** ./utils.js ***!
  \******************/
/*! exports provided: default */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash */ "lodash");\n/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);\n/**\n   Defines general utilities to use across projects\n   @module utils\n*/\n\n/**\n   @alias module:utils\n*/\n\nvar util = {};\n/* harmony default export */ __webpack_exports__["default"] = (util);\n/**\n   convert a string representation of an operator to its normal form\n   @param {String} operatorName See ReteComparisonOperators\n   @deprecated\n   @function\n*/\n\nutil.operatorToString = function (operatorName) {\n  var conversion = {\n    "EQ": "==",\n    "LT": "<",\n    "GT": ">",\n    "LTE": "<=",\n    "GTE": ">=",\n    "NE": "!=="\n  };\n\n  if (conversion[operatorName]) {\n    return conversion[operatorName];\n  }\n\n  console.warn("No conversion for operator:", operatorName);\n  return operatorName;\n};\n/**\n   Take a selection, append a wrapping classname,\n   offset by a global, and invidual amount, set a colour,\n   and use a passed in function to fill the texts\n   returning the resulting texts\n   @param boundDom\n   @param className\n   @param verticalOffset\n   @param nodeHeight\n   @param verticalSeparator\n   @param horizontalOffset\n   @param nodeWidth\n   @param colour\n   @param textFunction\n   @param textColour\n   @function\n*/\n\n\nutil.annotate = function (boundDom, className, verticalOffset, nodeHeight, verticalSeparator, horizontalOffset, nodeWidth, colour, textFunction, textColour) {\n  //Exit Selection:\n  boundDom.exit().remove(); //enter selection:\n\n  var enter = boundDom.enter().append("g").classed(className, true); //create new\n\n  enter.append("rect").classed(className + "rect", true);\n  enter.append("text").classed(className + "text", true).attr("dy", "1.4em"); //update:\n\n  boundDom.attr("transform", function (e, i) {\n    return "translate(" + horizontalOffset + "," + (verticalOffset + i * (nodeHeight + verticalSeparator)) + ")";\n  });\n  boundDom.selectAll("." + className + "rect").attr("width", nodeWidth - horizontalOffset * 2).attr("height", nodeHeight).style("fill", colour).attr("rx", 10).attr("ry", 10);\n  var texts = boundDom.selectAll("." + className + "text").attr("transform", "translate(" + horizontalOffset + "," + nodeHeight * 0.2 + ")").text(textFunction) //todo: parameterise this:\n  .style("fill", textColour || "white");\n  return texts;\n};\n/**\n   repeatedly truncate text until it fits in a certain amount of space;\n   @param d\n   @function\n*/\n\n\nutil.truncateDrawnText = function (d) {\n  // TODO: customise\n  var bbox = this.getBBox();\n  var maxLength = d.name.length - 4;\n\n  while (bbox.wdith > 10 && maxLength > 10) {\n    d.shortName = d.name.slice(0, maxLength) + "..."; //d3.select(this).text(d.shortName);\n\n    bbox = this.getBBox();\n    maxLength -= 2;\n  }\n};\n\n//# sourceURL=webpack://JGShell/./utils.js?')},lodash:
/*!*************************************************************************************!*\
  !*** external {"commonjs":"lodash","commonjs2":"lodash","amd":"lodash","root":"_"} ***!
  \*************************************************************************************/
/*! no static exports found */function(module,exports){eval("module.exports = __WEBPACK_EXTERNAL_MODULE_lodash__;\n\n//# sourceURL=webpack://JGShell/external_%7B%22commonjs%22:%22lodash%22,%22commonjs2%22:%22lodash%22,%22amd%22:%22lodash%22,%22root%22:%22_%22%7D?")}})});